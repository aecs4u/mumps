!
!  This file is part of MUMPS 5.8.2, released
!  on Mon Jan 12 15:17:08 UTC 2026
!
!
!  Copyright 1991-2026 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria,
!  Mumps Technologies, University of Bordeaux.
!
!  This version of MUMPS is provided to you free of charge. It is
!  released under the CeCILL-C license 
!  (see doc/CeCILL-C_V1-en.txt, doc/CeCILL-C_V1-fr.txt, and
!  https://cecill.info/licences/Licence_CeCILL-C_V1-en.html)
!
!     This file contains routines related to OOC,
!     panels, and pivoting. They are used to store
!     permutation information of what is already on
!     disk to be able to permute things back at the
!     solve stage.
!     They do not need to be in the MUMPS_OOC
!     module (most of them do not use any variable
!     from the module, or are called from routines
!     where we do not necessarily want to do a
!     USE @MUMPS_PREFIX@MUMPS_OOC).
INTEGER FUNCTION @MUMPS_PREFIX@MUMPS_OOC_GET_PANEL_SIZE &
  &     ( HBUF_SIZE, NNMAX, K227, K50 )
IMPLICIT NONE
!
!     Arguments:
!     =========
!
INTEGER, INTENT(IN) :: NNMAX, K227, K50
INTEGER(8), INTENT(IN) :: HBUF_SIZE
!
!     Purpose:
!     =======
!
!     - Compute the effective size (maximum number of pivots in a panel)
!     for a front with NNMAX entries in its row (for U) /
!     column (for L).
!     - Be able to adapt the fixed number of columns in panel
!     depending on NNMAX, and size of IO buffer HBUF_SIZE
!
!     Local variables
!     ===============
!
INTEGER K227_LOC
INTEGER NBCOL_MAX
INTEGER EFFECTIVE_SIZE
NBCOL_MAX=int(HBUF_SIZE / int(NNMAX,8))
!     KEEP(227): Maximum size (nb of col/row) of a panel
K227_LOC = abs(K227)
IF (K50.EQ.2) THEN
!        for 2x2 pivots we may end-up having the first part
!        of a 2x2 pivot in the last col of the panel; the
!        adopted solution consists in adding the next column
!        to the panel; therefore we need be able to
!        dynamically increase the panel size by one.
!        note that we also maintain property:
!        KEEP(227): Maximum size (nb of col/row) of a panel
   K227_LOC=max(K227_LOC,2)
   EFFECTIVE_SIZE =  min(NBCOL_MAX-1, K227_LOC-1)
!N       - during bwd the effective size is useless
ELSE
!        complete buffer space can be used for a panel
   EFFECTIVE_SIZE =  min(NBCOL_MAX, K227_LOC)
ENDIF
IF (EFFECTIVE_SIZE.LE.0) THEN
   write(6,*) 'Internal buffers too small to store ', &
  &        ' ONE col/row of size', NNMAX
   CALL MUMPS_ABORT()
ENDIF
@MUMPS_PREFIX@MUMPS_OOC_GET_PANEL_SIZE = EFFECTIVE_SIZE
RETURN
END FUNCTION @MUMPS_PREFIX@MUMPS_OOC_GET_PANEL_SIZE
!
SUBROUTINE @MUMPS_PREFIX@MUMPS_PERMUTE_PANEL( IPIV, LPIV, ISHIFT, &
  &     THE_PANEL, NBROW, NBCOL, KbeforePanel )
IMPLICIT NONE
!
!     Purpose:
!     =======
!
!     Permute rows of a panel, stored by columns, according
!     to permutation array IPIV.
!     IPIV is such that, for I = 1 to LPIV, row ISHIFT + I
!     in the front must be permuted with row IPIV( I )
!
!     Since the panel is not necessary at the beginning of
!     the front, let KbeforePanel be the number of pivots in the
!     front before the first pivot of the panel.
!
!     In the panel, row ISHIFT+I-KbeforePanel is permuted with
!     row IPIV(I)-KbeforePanel
!
!     Note:
!     ====
!
!     This routine can also be used to permute the columns of
!     a matrix (U) stored by rows. In that case, the argument
!     NBROW represents the number of columns, and NBCOL represents
!     the number of rows.
!
!
!     Arguments:
!     =========
!
INTEGER LPIV, ISHIFT, NBROW, NBCOL, KbeforePanel
INTEGER IPIV(LPIV)
@MUMPS_TYPE@ THE_PANEL(NBROW, NBCOL)
!
!     Local variables:
!     ===============
!
INTEGER I, IPERM
!
!     Executable statements
!     =====================
!
DO I = 1, LPIV
!        Swap rows ISHIFT + I and PIV(I)
   IPERM=IPIV(I)
   IF ( I+ISHIFT.NE.IPERM) THEN
      CALL @MUMPS_PREFIX_LOWER@swap(NBCOL, &
  &           THE_PANEL(I+ISHIFT-KbeforePanel,1), NBROW, &
  &           THE_PANEL(IPERM-KbeforePanel,1), NBROW)
   ENDIF
END DO
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_PERMUTE_PANEL
SUBROUTINE @MUMPS_PREFIX@MUMPS_GET_OOC_PERM_PTR(TYPEF, &
  &     NBPANELS, &
  &     I_PIVPTR, I_PIV, IPOS, IW, LIW)
USE MUMPS_OOC_COMMON ! To access TYPEF_L and TYPEF_U
IMPLICIT NONE
INCLUDE 'mumps_headers.h'
!
!     Purpose:
!     =======
!
!     Get the pointers in IW on pivoting information to be stored
!     during factorization and used during the solve phase. This
!     routine is both for the symmetric (TYPEF=TYPEF_L) and unsymmetric
!     cases (TYPEF=TYPEF_L or TYPEF_U).
!     The total size of this space is estimated during
!     fac_ass.F / fac_ass_ELT.F and must be:
!     * Symmetric case: 1 for NASS + 1 for NBPANELS_L + NBPANELS_L + NASS
!     * Unsymmetric case: 1 + (1+NBPANELS_L+NASS) + (1+NBPANELS_U+NASS)
!     Size computation is in routine @MUMPS_PREFIX@MUMPS_OOC_GET_PP_SIZES.
!
!     At the end of the standard description of the structure of a node
!     (header, nb slaves, <slaves_list>, row indices, col indices), we
!     add, when panel version with pivoting is used:
!
!     NASS (nb of fully summed variables)
!     NBPANELS_L
!     PIVRPTR(1:NBPANELS_L)
!     PIV_L     (1:NASS)             NASS (=IW(IPOS)(or NASS-PIVRPTR(1) in
!     the future, after compression)
!     NBPANELS_U
!     PIVRPTR(1:NBPANELS_U)
!     PIV_U     (1:NASS)             NASS (=IW(IPOS)(or NASS-PIVRPTR(1) in
!     the future, after compression)
!
!
!     Output parameters:
!     =================
!     NBPANELS : nb of panels as estimated during assembly
!     I_PIVPTR : position in  IW of the starting of the pointer list
!     (of size NBPANELS) of the pointers to the list of pivots
!     I_PIV    : position in  IW of the starting of the pivot permutation list
!
INTEGER, intent(out) :: NBPANELS, I_PIVPTR, I_PIV
INTEGER, intent(in) :: TYPEF ! TYPEF_L or TYPEF_U
INTEGER, intent(in) :: LIW, IPOS
INTEGER IW(LIW)
!     Locals
INTEGER I_NBPANELS, I_NASS
!
I_NASS       = IPOS
I_NBPANELS   = I_NASS + 1 ! L
NBPANELS     = IW(I_NBPANELS) ! L
I_PIVPTR     = I_NBPANELS + 1 ! L
I_PIV        = I_PIVPTR + NBPANELS ! L
!     ... of size NASS = IW(I_NASS)
IF (TYPEF==TYPEF_U) THEN
   I_NBPANELS   = I_PIV+IW(I_NASS) ! U
   NBPANELS     = IW(I_NBPANELS) ! U
   I_PIVPTR     = I_NBPANELS + 1 ! U
   I_PIV        = I_PIVPTR + NBPANELS ! U
ENDIF
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_GET_OOC_PERM_PTR
SUBROUTINE @MUMPS_PREFIX@MUMPS_OOC_PP_SET_PTR(K50,NBPANELS_L,NBPAN &
  &     NASS, IPOS, IW, LIW )
IMPLICIT NONE
!
!     Purpose:
!     =======
!
!     Initialize the contents of PIV/PIVPTR/etc. that will store
!     pivoting information during the factorization.
!     NASS and NBPANELS are recorded. PIVPTR(1:NBPANELS)
!     is initialized to NASS+1. This will be modified during
!     the factorization in cases where permutations have to
!     be performed during the solve phase.
!
!     Arguments:
!     =========
!
INTEGER K50
INTEGER IPOS, NASS, NBPANELS_L, NBPANELS_U, LIW
INTEGER IW(LIW)
!
!     Local variables:
!     ===============
!
INTEGER IPOS_U
!     Executable statements
IF (K50.EQ.1) THEN
   WRITE(*,*) "Internal error: @MUMPS_PREFIX@MUMPS_OOC_PP_SET_PTR
ENDIF
IW(IPOS)=NASS
IW(IPOS+1)=NBPANELS_L
IW(IPOS+2:IPOS+1+NBPANELS_L)=NASS+1
IF (K50 == 0) THEN
   IPOS_U=IPOS+2+NASS+NBPANELS_L
   IW(IPOS_U)=NBPANELS_U
   IW(IPOS_U+1:IPOS_U+NBPANELS_U)=NASS+1
ENDIF
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_OOC_PP_SET_PTR
SUBROUTINE @MUMPS_PREFIX@MUMPS_OOC_PP_TRYRELEASE_SPACE ( &
  &     IWPOS, IOLDPS, IW, LIW, MonBloc, NFRONT, KEEP &
  &     )
USE @MUMPS_PREFIX@MUMPS_OOC
IMPLICIT NONE
INCLUDE 'mumps_headers.h'
!
!     Purpose:
!     =======
!     If space used was at the top of the stack then
!     try to free space by detecting that
!     no permutation needs to be applied during
!     solve on panels.
!     One position is left (I_NASS) and set to -1
!     to indicate that permutation not needed at solve.
!
!     Arguments:
!     =========
!
INTEGER, INTENT(IN)    :: IOLDPS, LIW, NFRONT, &
  &     KEEP(500)
INTEGER, INTENT(INOUT) :: IWPOS, IW(LIW)
TYPE(IO_BLOCK), INTENT(IN):: MonBloc
!
!     Local variables:
!     ===============
!
INTEGER :: NBPANELS_L,I_PIVRPTR_L, I_PIVR_L, NBPANELS_U, &
  &     I_PIVRPTR_U, I_PIVR_U, XSIZE, IBEGOOC
LOGICAL FREESPACE    ! set to true when permutation not needed
!     Executable statements
IF (KEEP(50).EQ.1) RETURN ! no pivoting
!     --------------------------------
!     quick return if record is not at
!     the top of stack of L factors
IF ((IOLDPS+IW(IOLDPS+XXI)).NE.IWPOS) RETURN
!     ---------------------------------------------
!     Panel+pivoting: get pointers on each subarray
!     ---------------------------------------------
XSIZE   = KEEP(IXSZ)
IBEGOOC = IOLDPS+2*NFRONT+6+IW(IOLDPS+5+XSIZE)+XSIZE
!     -- get L related data
CALL @MUMPS_PREFIX@MUMPS_GET_OOC_PERM_PTR(TYPEF_L, NBPANELS_L, &
  &     I_PIVRPTR_L, I_PIVR_L, &
  &     IBEGOOC, IW, LIW)
FREESPACE = &
  &     (MonBloc%LastPiv.EQ.(IW(I_PIVRPTR_L)-1))
IF (KEEP(50).EQ.0) THEN
!     -- get U related dataA
   CALL @MUMPS_PREFIX@MUMPS_GET_OOC_PERM_PTR(TYPEF_U, NBPANELS_U, &
  &        I_PIVRPTR_U, I_PIVR_U, &
  &        IBEGOOC, IW, LIW)
   FREESPACE =  FREESPACE .AND. &
  &        (MonBloc%LastPiv.EQ.(IW(I_PIVRPTR_U)-1))
ENDIF
!     ---------------------------------
!     Check if permutations eed be
!     performed on panels during solve
!     --------------------------------
IF (FREESPACE) THEN
!     -- compress memory for that node: keep one entry set to -7777
   IW(IBEGOOC) = -7777    ! will be tested during solve
   IW(IOLDPS+XXI) = IBEGOOC &
  &        - IOLDPS + 1      ! new size of inode's record
   IWPOS = IBEGOOC+1      ! move back to top of stack
ENDIF
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_OOC_PP_TRYRELEASE_SPACE
!
SUBROUTINE @MUMPS_PREFIX@MUMPS_OOC_GET_PP_SIZES(K50, NBROW_L, NBCO &
  &     NBPANELS_L, NBPANELS_U, LREQ)
USE @MUMPS_PREFIX@MUMPS_OOC       ! To call @MUMPS_PREFIX@MUMPS_OO
IMPLICIT NONE
!
!     Purpose
!     =======
!
!     Compute the size of the workspace required to store the permutation
!     information during factorization, so that solve can permute back
!     what has to be permuted (this could not be done during factorization
!     because it was already on disk).
!
!     Arguments
!     =========
!
INTEGER, intent(IN)  :: K50, NBROW_L, NBCOL_U, NASS
INTEGER, intent(OUT) :: NBPANELS_L, NBPANELS_U, LREQ
NBPANELS_L=-99999
NBPANELS_U=-99999
!
!     Quick return in SPD case (no pivoting)
!
IF (K50.EQ.1) THEN
   LREQ = 0
   RETURN
ENDIF
!
!     L information is always computed
!
NBPANELS_L = (NASS / @MUMPS_PREFIX@MUMPS_OOC_PANEL_SIZE(NBROW_L))+
LREQ =    1               ! Store NASS &
  &     + 1                  ! Store NBPANELS_L &
  &     + NASS               ! Store permutations &
  &     + NBPANELS_L         ! Store pointers on permutations
IF (K50.eq.0) THEN
!
!     Also take U information into account
!
   NBPANELS_U = (NASS / @MUMPS_PREFIX@MUMPS_OOC_PANEL_SIZE(NBCOL_U
   LREQ = LREQ + 1        ! Store NBPANELS_U &
  &        + NASS            ! Store permutations &
  &        + NBPANELS_U      ! Store pointers on permutations
ENDIF
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_OOC_GET_PP_SIZES
SUBROUTINE @MUMPS_PREFIX@MUMPS_OOC_PP_CHECK_PERM_FREED &
  &           (IW_LOCATION, MUST_BE_PERMUTED)
IMPLICIT NONE
INTEGER, INTENT(IN) :: IW_LOCATION
LOGICAL, INTENT(INOUT) :: MUST_BE_PERMUTED
!
!     Purpose
!     =======
!
!     Reset MUST_BE_PERMUTED to .FALSE. when we detect
!     that the @MUMPS_PREFIX@MUMPS_OOC_PP_TRY_RELEASE_SPACE has freed
!     the permutation information (see that routine).
!
IF (IW_LOCATION .EQ. -7777) THEN
  MUST_BE_PERMUTED = .FALSE.
ENDIF
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_OOC_PP_CHECK_PERM_FREED
