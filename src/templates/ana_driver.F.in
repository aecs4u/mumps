!
!  This file is part of MUMPS 5.8.2, released
!  on Mon Jan 12 15:17:08 UTC 2026
!
!
!  Copyright 1991-2026 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria,
!  Mumps Technologies, University of Bordeaux.
!
!  This version of MUMPS is provided to you free of charge. It is
!  released under the CeCILL-C license 
!  (see doc/CeCILL-C_V1-en.txt, doc/CeCILL-C_V1-fr.txt, and
!  https://cecill.info/licences/Licence_CeCILL-C_V1-en.html)
!
!
SUBROUTINE @MUMPS_PREFIX@MUMPS_ANA_DRIVER(id,idintr)
USE MUMPS_STATIC_MAPPING
USE @MUMPS_PREFIX@MUMPS_STRUC_DEF
USE @MUMPS_PREFIX@MUMPS_INTR_TYPES, ONLY: @MUMPS_PREFIX@MUMPS_INTR_STRUC
USE MUMPS_MEMORY_MOD
USE @MUMPS_PREFIX@MUMPS_PARALLEL_ANALYSIS
USE @MUMPS_PREFIX@MUMPS_ANA_LR
USE @MUMPS_PREFIX@MUMPS_LR_CORE
USE MUMPS_LR_STATS
USE MUMPS_LR_COMMON
USE @MUMPS_PREFIX@MUMPS_ANA_AUX_M
USE MUMPS_ANA_BLK_M, ONLY: COMPACT_GRAPH_T, LMATRIX_T
IMPLICIT NONE
INTERFACE
!     Explicit interfaces when id has the TARGET attribute
SUBROUTINE @MUMPS_PREFIX@MUMPS_ANA_ARROWHEADS_WRAPPER &
  &          (id, GATHER_MATRIX_ALLOCATED)
USE @MUMPS_PREFIX@MUMPS_STRUC_DEF
TYPE (@MUMPS_PREFIX@MUMPS_STRUC), TARGET :: id
LOGICAL, INTENT(INOUT) :: GATHER_MATRIX_ALLOCATED
END SUBROUTINE @MUMPS_PREFIX@MUMPS_ANA_ARROWHEADS_WRAPPER
SUBROUTINE @MUMPS_PREFIX@MUMPS_ANA_COMPUTE_ESTIMATES (id, idintr)
USE @MUMPS_PREFIX@MUMPS_STRUC_DEF
USE @MUMPS_PREFIX@MUMPS_INTR_TYPES, ONLY: @MUMPS_PREFIX@MUMPS_INTR_STRUC
TYPE (@MUMPS_PREFIX@MUMPS_STRUC), TARGET :: id
TYPE (@MUMPS_PREFIX@MUMPS_INTR_STRUC)    :: idintr
END SUBROUTINE @MUMPS_PREFIX@MUMPS_ANA_COMPUTE_ESTIMATES
END INTERFACE
!     
INCLUDE 'mpif.h'
INCLUDE 'mumps_tags.h'
INTEGER IERR, MASTER
PARAMETER( MASTER = 0 )
!
!     Purpose
!     =======
!
!     Performs analysis and (if required) Max-trans on the master, then
!     broadcasts information to the slaves. Also includes mapping.
!     
!
!     Parameters
!     ==========
!
TYPE(@MUMPS_PREFIX@MUMPS_STRUC), TARGET :: id
TYPE(@MUMPS_PREFIX@MUMPS_INTR_STRUC) :: idintr
!
!     Local variables
!     ===============
!
!
!     Pointers inside integer array IKEEPALLOC, various data
INTEGER(8) IKEEP, NE, NA
INTEGER I, allocok
!     Other locals
INTEGER NB_NIV2, IDEST
INTEGER :: STATUS(MPI_STATUS_SIZE)
INTEGER MP, LP, MPG
LOGICAL PROK, PROKG, LISTVAR_SCHUR_2BE_FREED, LPOK
INTEGER SIZE_SCHUR_PASSED
INTEGER LEAF, INODE, ISTEP, INN, LPTRAR
INTEGER NBLEAF, NBROOT, MYROW_CHECK, INIV2
DOUBLE PRECISION TIMEG
@MUMPS_REAL_TYPE@      :: PEAK
! 
!     Related to commuicators for parallel analysis:
!       COMM_PARAORD: communicator on which Parmetis/PTscotch 
!                   is performed
!       COMM_PARASYMB: communicator on which parallel symbolic 
!                   facto is performed
!       PARAORD_to_idCOMM (1:NPROCS_PARAORD) is such that 
!                   PARAORD_to_idCOMM(idPARAORD+1)=idCOMM, 
!                   where idPARAORD \in [0:NPROCS_PARAORD]
!       RKinSYMB_PROC0ORD: Rank in COMM_PARASYMB of proc 0 in 
!                          COMM_PARAORD
!       RKinidCOMM_PROC0SYMB: Rank in id%COMM of proc 0 in 
!                             COMM_PARASYMB
!    
INTEGER :: COMM_PARAORD, NPROCS_PARAORD, RKinSYMB_PROC0ORD, &
  &           OPTION_COMM_PARAORD
INTEGER :: COMM_PARASYMB, NPROCS_PARASYMB, &
  &           RKinidCOMM_PROC0SYMB
LOGICAL :: COMM_PARAORD_ALLOCATED, COMM_PARASYMB_ALLOCATED
INTEGER, ALLOCATABLE, DIMENSION(:) :: PARAORD_to_idCOMM
#if defined(AVOID_MPI_IN_PLACE)
INTEGER, ALLOCATABLE, DIMENSION(:) :: TMP
#endif
!     
!     INTEGER WORKSPACE 
!     
INTEGER, ALLOCATABLE, TARGET, DIMENSION(:) :: PAR2_NODES
INTEGER, DIMENSION(:), POINTER             :: PAR2_NODESPTR
INTEGER, ALLOCATABLE, DIMENSION(:) :: PROCNODE
INTEGER, DIMENSION(:), ALLOCATABLE :: IWtemp
INTEGER, DIMENSION(:), ALLOCATABLE :: XNODEL, NODEL
INTEGER, DIMENSION(:), POINTER :: SSARBR
!     Element matrix entry
INTEGER, POINTER ::  NELT, LELTVAR
INTEGER, DIMENSION(:), POINTER :: KEEP, INFO, INFOG
INTEGER(8), DIMENSION(:), POINTER :: KEEP8
@MUMPS_REAL_TYPE@, DIMENSION(:), POINTER :: RINFO
@MUMPS_REAL_TYPE@, DIMENSION(:), POINTER :: RINFOG
INTEGER, DIMENSION(:), POINTER :: ICNTL
LOGICAL :: I_AM_SLAVE, COND
INTEGER, TARGET    :: IDUMMY_ARRAY(1)
INTEGER(8)                     :: NNZ_loc, NNZ_TMP
INTEGER, POINTER, DIMENSION(:) :: IRN_loc_PTR
INTEGER, POINTER, DIMENSION(:) :: JCN_loc_PTR
INTEGER, POINTER, DIMENSION(:) :: IRN_PTR
INTEGER, POINTER, DIMENSION(:) :: JCN_PTR
INTEGER, POINTER, DIMENSION(:) :: SIZEOFBLOCKS_PTR
INTEGER, POINTER, DIMENSION(:) :: UNS_PERM_PTR
!$    INTEGER :: NOMPMAX
INTEGER MUMPS_TYPENODE, MUMPS_PROCNODE
EXTERNAL MUMPS_TYPENODE, MUMPS_PROCNODE
INTEGER, EXTERNAL :: MUMPS_ENCODE_TPN_IPROC
INTEGER :: PROCNODE_VALUE
INTEGER K,J, IFS
INTEGER SIZE_TEMP_MEM,SIZE_DEPTH_FIRST,SIZE_COST_TRAV
LOGICAL IS_BUILD_LOAD_MEM_CALLED
LOGICAL PRINT_MAXAVG
LOGICAL :: PRINT_NODEINFO
DOUBLE PRECISION, DIMENSION (:,:), ALLOCATABLE :: TEMP_MEM
INTEGER, DIMENSION (:,:), ALLOCATABLE :: TEMP_ROOT
INTEGER, DIMENSION (:,:), ALLOCATABLE :: TEMP_LEAF
INTEGER, DIMENSION (:,:), ALLOCATABLE :: TEMP_SIZE
INTEGER, DIMENSION (:), ALLOCATABLE :: DEPTH_FIRST
INTEGER, DIMENSION (:), ALLOCATABLE :: DEPTH_FIRST_SEQ
INTEGER, DIMENSION (:), ALLOCATABLE :: SBTR_ID
@MUMPS_REAL_TYPE@, DIMENSION (:), ALLOCATABLE :: COST_TRAV_TMP
INTEGER          :: SIZE_PAR2_NODESPTR
INTEGER          :: LSIZEOFBLOCKS_PTR
LOGICAL          :: READY_FOR_ANA_F
INTEGER, ALLOCATABLE, DIMENSION(:) :: MAPCOL
LOGICAL :: BLKPTR_ALLOCATED, BLKVAR_ALLOCATED
INTEGER, POINTER, DIMENSION(:) :: BLKPTR_PTRLOC, BLKVAR_PTRLOC
INTEGER :: IB, BLKSIZE
INTEGER :: IBcurrent, IPOS, IPOSB, II
!      Internal work arrays:
!      DOF2BLOCK(idof)=inode, idof in [1,N], inode in [1,NBLK]
!      SIZEBLOCK(1:NBLK) (for node valuation) 
INTEGER, TARGET, DIMENSION(:), allocatable:: SIZEOFBLOCKS
INTEGER, DIMENSION(:), allocatable:: DOF2BLOCK
INTEGER    :: NBRECORDS
INTEGER(8) :: NSEND8, NLOCAL8, IDUMMY8
!     LMAT_BLOCK: in case of centralized matrix, 
!                 to store on MASTER the cleaned Lmatrix
!                 used to compute GCOMP
!                 LMAT_BLOCK might also be saved to 
!                 be used during grouping
!     LUMAT     : in case of distributed matrix
!                 to store distributed the cleaned LU matrix
!                 LUMAT might also be saved to 
!                 be used for MPI based grouping
!     LUMAT_REMAP : in case of distributed matrix
!                 it is used to remap LUMAT
! 
!     GCOMP     : Graph "ready" to be called by orderings
!
INTEGER(8)            :: MEMCNT
TYPE(LMATRIX_T)       :: LMAT_BLOCK, LUMAT, LUMAT_REMAP
INTEGER               :: LMAT_BLOCK_AVAIL_I
LOGICAL               :: GCOMP_PROVIDED, &
  &                         LUMAT_AVAIL, LMAT_BLOCK_AVAIL
LOGICAL               :: LUMAT_REMAP_DIST_AVAIL, &
  &                         LUMAT_REMAP_CENT_AVAIL
TYPE(COMPACT_GRAPH_T) :: GCOMP
TYPE(COMPACT_GRAPH_T) :: GCOMP_DIST
INTEGER(4) :: I4
INTEGER, POINTER, DIMENSION(:) :: &
  &     NFSIZPTR, &
  &     FREREPTR, &
  &     IKEEP1, IKEEP2, IKEEP3
#if defined(MUMPS_NOF2003)
INTEGER, POINTER, DIMENSION(:) ::  FILS_TMPPTR
#endif
INTEGER, ALLOCATABLE, DIMENSION(:), TARGET :: FILS_TMP
INTEGER, ALLOCATABLE, DIMENSION(:) :: STEP_TMP, &
  &                                      LRGROUPS_TMP
INTEGER, ALLOCATABLE, DIMENSION(:), TARGET :: IKEEPALLOC
INTEGER, ALLOCATABLE, DIMENSION(:) :: WORK2ALLOC
INTEGER :: SIZELRGROUPS_TMP
INTEGER(8) :: SIZEIKEEPALLOC, SIZEWORK2ALLOC
INTEGER(kind=8) :: NZ8, LIW8
!     NBLK : id%N or order of blocked matrix
INTEGER :: NBLK, idNBLKSAVE
INTEGER(8) :: LIW8_ELT
!     GATHER_MATRIX_ALLOCATED: 
!     To be sure that id%IRN and id%JCN are
!     deallocated only when @MUMPS_PREFIX@MUMPS_GATHER_MATRIX was called
LOGICAL :: GATHER_MATRIX_ALLOCATED
!
!  Beginning of executable statements
!
!     @MUMPS_PREFIX@MUMPS_FREE_DATA_ANAFACSOL was called in @MUMPS_PREFIX@MUMPS_DRIVER
!     to reduce the memory peak during analysis, especially
!     when computing the graph associated to the input matrix.
IS_BUILD_LOAD_MEM_CALLED=.FALSE.
KEEP   => id%KEEP
KEEP8  => id%KEEP8
INFO   => id%INFO
RINFO  => id%RINFO
INFOG  => id%INFOG
RINFOG => id%RINFOG
ICNTL  => id%ICNTL
NELT    => id%NELT
LELTVAR => id%LELTVAR
KEEP(264) = 0    ! reinitialise out-of-range status (0=yes)
KEEP(265) = 0    ! reinitialise dupplicates (0=yes)
KEEP(280) = 0    ! size of id%LRGROUPS
PRINT_MAXAVG = .NOT.(id%NSLAVES.EQ.1 .AND. KEEP(46).EQ.1)
!     FIXME: count memory used during analysis
MEMCNT = 0_8
!     Print per node information only in case there are several
!     compute nodes (id%KEEP(412): #MPI procs on compute node)
PRINT_NODEINFO = PRINT_MAXAVG .AND. id%NPROCS .NE. id%KEEP(412)
GATHER_MATRIX_ALLOCATED = .FALSE.
COMM_PARAORD            = MPI_COMM_NULL
COMM_PARASYMB           = id%COMM
COMM_PARAORD_ALLOCATED  = .FALSE.
COMM_PARASYMB_ALLOCATED = .FALSE.
RKinidCOMM_PROC0SYMB    = MASTER
NULLIFY ( NFSIZPTR, FREREPTR, &
  &     IKEEP1, IKEEP2, IKEEP3, &
  &     SSARBR, SIZEOFBLOCKS_PTR, IRN_loc_PTR, JCN_loc_PTR, &
  &     IRN_PTR, JCN_PTR, &
  &     PAR2_NODESPTR, BLKPTR_PTRLOC, BLKVAR_PTRLOC)
IF (associated(id%UNS_PERM)) DEALLOCATE(id%UNS_PERM)
nullify(id%UNS_PERM)
!     Set default value that witl be reset in
!     case of blocked format matrices
NBLK = id%N
GCOMP_PROVIDED   = .FALSE.
BLKPTR_ALLOCATED = .FALSE.
BLKVAR_ALLOCATED = .FALSE.
LUMAT_AVAIL      = .FALSE.
LMAT_BLOCK_AVAIL = .FALSE.
!     -------------------------------------
!     Depending on the type of parallelism,
!     the master can now (soon) potentially
!     have the role of a slave
!     -------------------------------------
I_AM_SLAVE = ( id%MYID .ne. MASTER  .OR. &
  &     ( id%MYID .eq. MASTER .AND. &
  &     id%KEEP(46) .eq. 1 ) )
LP  = ICNTL( 1 )
MP  = ICNTL( 2 )
MPG = ICNTL( 3 )
!     LP     : errors
!     MP     : INFO
LPOK  = ((LP.GT.0).AND.(id%ICNTL(4).GE.1))
PROK  = (( MP  .GT. 0 ).AND.(ICNTL(4).GE.2))
PROKG = ( MPG .GT. 0 .and. id%MYID .eq. MASTER )
PROKG = (PROKG.AND.(ICNTL(4).GE.2))
IF ( PROK ) THEN
   IF ( KEEP(50) .eq. 0 ) THEN
      WRITE(MP, '(A)') 'L U Solver for unsymmetric matrices'
   ELSE IF ( KEEP(50) .eq. 1 ) THEN
      WRITE(MP, '(A)') &
  & 'L D L^T Solver for symmetric positive definite matrices'
   ELSE
      WRITE(MP, '(A)') &
  &           'L D L^T Solver for general symmetric matrices'
   END IF
   IF ( KEEP(46) .eq. 1 ) THEN
      WRITE(MP, '(A)') 'Type of parallelism: Working host'
   ELSE
      WRITE(MP, '(A)') 'Type of parallelism: Host not working'
   END IF
END IF
IF ( PROKG .AND. (MP.NE.MPG)) THEN
   IF ( KEEP(50) .eq. 0 ) THEN
      WRITE(MPG, '(A)') 'L U Solver for unsymmetric matrices'
   ELSE IF ( KEEP(50) .eq. 1 ) THEN
      WRITE(MPG, '(A)') &
  & 'L D L^T Solver for symmetric positive definite matrices'
   ELSE
      WRITE(MPG, '(A)') &
  &           'L D L^T Solver for general symmetric matrices'
   END IF
   IF ( KEEP(46) .eq. 1 ) THEN
      WRITE(MPG, '(A)') 'Type of parallelism: Working host'
   ELSE
      WRITE(MPG, '(A)') 'Type of parallelism: Host not working'
   END IF
END IF
IF (PROK) WRITE( MP, 110 )
IF (PROKG .AND. (MPG.NE.MP)) WRITE( MPG, 110 )
!     Reinitialize last used size of WK_USER
!     ---------------------------------------
KEEP8(24) = 0_8
!
!
!
!     Decode API (ICNTL parameters, mainly)
!     and check consistency of the KEEP array.
!     Note: @MUMPS_PREFIX@MUMPS_ANA_CHECK_KEEP also sets
!     some INFOG parameters
CALL @MUMPS_PREFIX@MUMPS_ANA_CHECK_KEEP(id, I_AM_SLAVE)
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &     id%COMM, id%MYID )
IF ( INFO(1) .LT. 0 ) GOTO 500
!     -------------------------------------------
!     Broadcast KEEP(60) since we need to broadcast
!     related information
!     ------------------------------------------
CALL MPI_BCAST( KEEP(60), 1, MPI_INTEGER, MASTER, id%COMM, IERR )
!        broadcast also size of schur
IF (id%KEEP(60) .NE. 0 ) THEN
 CALL MPI_BCAST( KEEP(116), 1, MPI_INTEGER, MASTER, &
  &                   id%COMM, IERR )
ENDIF
IF (id%KEEP(60) .EQ. 2 .or. id%KEEP(60). EQ. 3) THEN
   CALL MPI_BCAST( id%NPROW, 1, &
  &        MPI_INTEGER, MASTER, id%COMM, IERR )
   CALL MPI_BCAST( id%NPCOL, 1, &
  &        MPI_INTEGER, MASTER, id%COMM, IERR )
   CALL MPI_BCAST( id%MBLOCK, 1, &
  &        MPI_INTEGER, MASTER, id%COMM, IERR )
   CALL MPI_BCAST( id%NBLOCK, 1, &
  &        MPI_INTEGER, MASTER, id%COMM, IERR )
!     Note that @MUMPS_PREFIX@MUMPS_INIT_ROOT_ANA will
!     then use that information.
ENDIF
!     ----------------------------------------------
!     Broadcast KEEP(54) now to know if the
!     structure of the graph is intially distributed
!     and should be assembled on the master
!     Broadcast KEEP(55) now to know if the
!     matrix is in assembled or elemental format
!     ----------------------------------------------
CALL MPI_BCAST( KEEP(54), 2, MPI_INTEGER, MASTER, id%COMM, IERR )
!     ----------------------------------------------
!     Broadcast KEEP(69) now to know if
!     we will need to communicate during analysis
!     ----------------------------------------------
CALL MPI_BCAST( KEEP(69), 1, MPI_INTEGER, MASTER, id%COMM, IERR )
!     ----------------------------------------------
!     Broadcast Out of core strategy (used only on master so far)
!     Boradcast KEEP(201), KEEP(202) and KEEP(203)
!     ----------------------------------------------
CALL MPI_BCAST( KEEP(201), 3, MPI_INTEGER, MASTER, id%COMM, IERR )
!     ----------------------------------------------
!     Broadcast analysis strategy (used only on master so far)
!     ----------------------------------------------
CALL MPI_BCAST( KEEP(244), 1, MPI_INTEGER, MASTER, id%COMM, IERR )
IF (KEEP(244).NE.1) THEN
!       broadcast parallel ordering strategy used
  CALL MPI_BCAST( KEEP(245), 1, MPI_INTEGER, MASTER, &
  &                  id%COMM, IERR )
ENDIF
!     ---------------------------
!     Fwd in facto
!     Broadcast KEEP(251,252,253) defined on master so far
CALL MPI_BCAST( KEEP(251), 3, MPI_INTEGER,MASTER,id%COMM,IERR)
!
CALL MPI_BCAST( KEEP(401), 1, MPI_INTEGER,MASTER,id%COMM,IERR)
id%KEEP(400) = 0
id%KEEP(369) = id%KEEP(368)
!$    IF (id%KEEP(401).GT.0) THEN
!$       id%KEEP(400) = omp_get_max_threads()
!          => id%KEEP(400)>=1 
!  
!        IF KEEP(400)<=1 on all procs switch off L0 thread:
!$       CALL MPI_ALLREDUCE(id%KEEP(400),NOMPMAX,1,MPI_INTEGER,
!$   &                      MPI_MAX,id%COMM,IERR)
!$       IF (NOMPMAX.LE.1) THEN
!$          id%KEEP(400) = 0
!$          id%KEEP(401) = 0
!$       ENDIF
!$    ENDIF 
!$    IF (id%KEEP(400).GT.0 .AND. id%KEEP(401).GT.0
!$   &                      .AND. id%KEEP(369).GT.0) THEN
!      reset id%KEEP(400) to value provided by user
!$       id%KEEP(400) = min(id%KEEP(400),id%KEEP(369))
!$    ENDIF
CALL MPI_BCAST( id%KEEP(490), 5, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
CALL MPI_BCAST( KEEP(123),1,MPI_INTEGER,MASTER,id%COMM,IERR)
!     ----------------------------------------------
!     Broadcast N 
!     ----------------------------------------------
CALL MPI_BCAST( id%N, 1, MPI_INTEGER, MASTER, id%COMM, IERR )
!     ----------------------------------------------
!     Broadcast NZ for assembled entry
!     ----------------------------------------------
IF ( KEEP(55) .EQ. 0) THEN
   IF ( KEEP(54) .eq. 3 ) THEN
!         Reset to 0 id%KEEP8(29) for host not working, since 
!         value provided by user might be undefined
    IF (.NOT.I_AM_SLAVE) id%KEEP8(29)= 0_8
!     Compute total number of non-zeros
    CALL MPI_ALLREDUCE( id%KEEP8(29), id%KEEP8(28), 1, &
  &       MPI_INTEGER8, &
  &       MPI_SUM, id%COMM, IERR )
!         Local number of non-zeros cannot be negative
    IF (id%KEEP8(29) .LT. 0_8) THEN
          id%INFO(1) = -2
          CALL MUMPS_SET_IERROR(id%KEEP8(29), id%INFO(2))
    ENDIF
   ELSE
!     Broadcast NZ from the master node
      CALL MPI_BCAST( id%KEEP8(28), 1, MPI_INTEGER8, MASTER, &
  &           id%COMM, IERR )
   END IF
!     Total number of non zeros must be positive strictly
   IF (id%KEEP8(28) .LE. 0_8) THEN
          id%INFO(1) = -2
          CALL MUMPS_SET_IERROR(id%KEEP8(28), id%INFO(2))
   ENDIF
ELSE
!     Broadcast NA_ELT <=> KEEP8(30) for elemental entry
   CALL MPI_BCAST( id%KEEP8(30), 1, MPI_INTEGER8, MASTER, &
  &        id%COMM, IERR )
ENDIF
IF( id%KEEP(54).EQ.3) THEN
!     test IRN_loc and JCN_loc allocated on working procs
 IF (I_AM_SLAVE .AND. id%KEEP8(29).GT.0 .AND. &
  &     ( (.NOT. associated(id%IRN_loc)) .OR. &
  &       (.NOT. associated(id%JCN_loc)) ) &
  &   ) THEN
   id%INFO(1) = -22
   id%INFO(2) = 16
 ENDIF
ENDIF
IF ( associated(id%MEM_DIST) ) THEN
   DEALLOCATE( id%MEM_DIST )
ENDIF
allocate( id%MEM_DIST( 0:id%NSLAVES-1 ), STAT=IERR )
IF ( IERR .GT. 0 ) THEN
   INFO(1) = -7
   INFO(2) = id%NSLAVES
   IF ( LPOK ) THEN
      WRITE(LP, 150) 'MEM_DIST'
   END IF
END IF
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &     id%COMM, id%MYID )
IF ( INFO(1) .LT. 0 ) GOTO 500
id%MEM_DIST(0:id%NSLAVES-1) = 0
CALL MUMPS_INIT_ARCH_PARAMETERS( &
  &     id%COMM,id%COMM_NODES,KEEP(69),KEEP(46), &
  &     id%NSLAVES,id%MEM_DIST,INFO )
!     ========================
!     Write problem to a file,
!     if requested by the user
!     ========================
CALL @MUMPS_PREFIX@MUMPS_DUMP_PROBLEM(id)
IF ( id%INFO(1) .LT. 0 ) GOTO 500
!     =================
!     ANALYSIS BY BLOCK 
!     =================
IF ( id%MYID .EQ. MASTER ) THEN
 IF (KEEP(13).EQ.1) THEN
    NBLK=id%NBLK
 ELSE IF (KEEP(13).LT.0) THEN
!        regular blocks in BLKVAR of size -KEEP(13)
!        mod(id%N,-KEEP(13)) has already been checked
   NBLK = id%N/(-KEEP(13))
 ENDIF
!      end of  id%MYID .EQ. MASTER 
ENDIF
CALL MUMPS_PROPINFO( id%ICNTL(1), id%INFO(1), &
  &     id%COMM, id%MYID )
IF ( id%INFO(1) .LT. 0 ) GOTO 500
!
!     Broadcast KEEP(13-14), NBLK
CALL MPI_BCAST( KEEP(13), 2, MPI_INTEGER, MASTER, id%COMM, IERR )
CALL MPI_BCAST( NBLK, 1, MPI_INTEGER, MASTER, id%COMM, IERR )
!
!     ===========================
IF (KEEP(13).NE.0) THEN
!     { BEGIN preparation ANA_BLK
!     ===========================
 IF ( &
  &     ( KEEP(244).NE.1) &
  &    .OR. ( (KEEP(54).NE.3).AND.(id%MYID.EQ.MASTER) ) &
  &    .OR.  (KEEP(54).EQ.3) ) THEN
!{
!         ----------------------------------------
!         Allocate SIZEOFBLOCKS, DOF2BLOCK
!         ----------------------------------------
    IF (allocated(SIZEOFBLOCKS)) DEALLOCATE(SIZEOFBLOCKS)
    IF (allocated(DOF2BLOCK)) DEALLOCATE(DOF2BLOCK)
    allocate(SIZEOFBLOCKS(NBLK), DOF2BLOCK(id%N), &
  &                  STAT=allocok)
!
    IF (allocok.NE.0) THEN
     id%INFO( 1 ) = -7
     id%INFO( 2 ) = id%N+NBLK
     IF ( LPOK ) WRITE(LP, 150) ' SIZEOFBLOCKS, DOF2BLOCK'
    ENDIF
!
    IF ( (allocok.EQ.0) .AND. (id%MYID.EQ.MASTER)) THEN
!{           BLKPTR and BLKVAR needed for @MUMPS_PREFIX@MUMPS_EXPAND_TREE
!            allocate then if not associated
       IF (.NOT.associated(id%BLKPTR).OR.KEEP(13).LT.0) THEN
        BLKPTR_ALLOCATED = .TRUE.
!              allocate(id%BLKPTR(NBLK+1), STAT=allocok)
        allocate(BLKPTR_PTRLOC(NBLK+1), STAT=allocok)
        IF (allocok.NE.0) THEN
         BLKPTR_ALLOCATED = .FALSE.
         id%INFO( 1 ) = -7
         id%INFO( 2 ) = NBLK+1
         IF ( LPOK ) WRITE(LP, 150) ' id%BLKPTR '
        ENDIF
       ELSE
         BLKPTR_PTRLOC=>id%BLKPTR
       ENDIF
       IF (allocok.EQ.0) THEN
        IF (.NOT.associated(id%BLKVAR).OR.KEEP(13).LT.0) THEN
         allocate(BLKVAR_PTRLOC(id%N), STAT=allocok)
         BLKVAR_ALLOCATED = .TRUE.
         IF (allocok.NE.0) THEN
          BLKVAR_ALLOCATED = .FALSE.
          id%INFO( 1 ) = -7
          id%INFO( 2 ) = id%N
          IF ( LPOK ) WRITE(LP, 150) ' id%BLKVAR '
         ENDIF
        ELSE
         BLKVAR_PTRLOC => id%BLKVAR
        ENDIF
       ENDIF
!}
    ENDIF
!} 
 ENDIF
 CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &     id%COMM, id%MYID )
 IF (INFO(1).LT.0) GOTO 500
 IF ( id%MYID .EQ. MASTER ) THEN
!{     -----------------------------------------
!      Compute SIZEOFBLOCKS, DOF2BLOCK on MASTER
!      based on id%BLKPTR and id%BLKVAR 
!      and compute id%BLKPTR and id%BLKVAR if not 
!      provided by user
!      -----------------------------------------
     IF (BLKVAR_ALLOCATED) THEN
!           implicitly id%BLKVAR(I)=I
      DO I=1, id%N
       BLKVAR_PTRLOC(I)=I
      ENDDO
     ENDIF
     IF (BLKPTR_ALLOCATED) THEN
      IB=0
      BLKSIZE=-KEEP(13)
      DO I=1, id%N, BLKSIZE
        IB=IB+1
        BLKPTR_PTRLOC(IB) = I
      ENDDO
      BLKPTR_PTRLOC(NBLK+1) = id%N+1
     ENDIF
!
     CALL MUMPS_AB_COMPUTE_SIZEOFBLOCK ( &
  &          NBLK, id%N, BLKPTR_PTRLOC(1), BLKVAR_PTRLOC(1), &
  &          SIZEOFBLOCKS, DOF2BLOCK)
!}
 ENDIF
!     ========================
IF (KEEP(244).NE.1) THEN
!{    Parallel analysis
!     ========================
!        KEEP(13).ne.0 only if KEEP(339).NE.0 :
    IF (KEEP(339).EQ.0) THEN
      INFO(1) = -901
      INFO(2) = KEEP(13)
      IF ( LPOK ) WRITE(LP, 150) ' Internal error K339'
    ENDIF
    NNZ_loc = 0_8
!         -----------------------------------------
!         Build distributed clean LUMAT matrix
!         even when matrix is provided centralised
!         -----------------------------------------
    IF (KEEP(54).EQ.3) THEN
      IF (.NOT. I_AM_SLAVE .OR. ! non-working master &
  &        KEEP8(29) .EQ. 0_8) THEN ! NNZ_loc or NZ_loc
!             Master non-working
        IRN_loc_PTR => IDUMMY_ARRAY
        JCN_loc_PTR => IDUMMY_ARRAY
      ELSE
        IRN_loc_PTR => id%IRN_loc
        JCN_loc_PTR => id%JCN_loc
        NNZ_loc  = KEEP8(29)
      ENDIF
    ELSE
!           Matrix on host
      IF (id%MYID.EQ.MASTER) THEN
!            Store input matrix (IRN/JCN) as a cleaned blocked Lmatrix 
!            of nodes (indices \in [1,NBLK])
       IF (id%KEEP8(28) .EQ. 0_8) THEN
         IRN_loc_PTR => IDUMMY_ARRAY
         JCN_loc_PTR => IDUMMY_ARRAY
       ELSE
         IRN_loc_PTR => id%IRN
         JCN_loc_PTR => id%JCN
         NNZ_loc     = id%KEEP8(28)
       ENDIF
      ELSE
        IRN_loc_PTR => IDUMMY_ARRAY
        JCN_loc_PTR => IDUMMY_ARRAY
      ENDIF
    ENDIF
!        build communicator for parallel ordering 
!        used to distribute LUMAT
   OPTION_COMM_PARAORD = 0
   CALL  MUMPS_BUILD_COMM_PARA_ANA ( &
  &          OPTION_COMM_PARAORD, id%N, &
  &          id%COMM, id%MYID, id%COMM_NODES, id%MYID_NODES, &
  &          id%NPROCS, id%NSLAVES, &
  &          id%KEEP(1), &
  &          COMM_PARAORD, NPROCS_PARAORD, &
  &          COMM_PARAORD_ALLOCATED, &
  &          COMM_PARASYMB, NPROCS_PARASYMB, &
  &          COMM_PARASYMB_ALLOCATED, &
  &          id%ICNTL(1), id%INFO(1))
!         allocate and initialize PARAORD_to_idCOMM
    if (allocated(PARAORD_to_idCOMM)) &
  &         DEALLOCATE(PARAORD_to_idCOMM)
    allocate(PARAORD_to_idCOMM(NPROCS_PARAORD),
#if defined(AVOID_MPI_IN_PLACE)
  &             TMP(NPROCS_PARAORD),
#endif
  &             STAT=allocok)
    IF (allocok.NE.0) THEN
      id%INFO( 1 ) = -7
      id%INFO( 2 ) = NPROCS_PARAORD
#if defined(AVOID_MPI_IN_PLACE)
  &                   + NPROCS_PARAORD
#endif
      IF ( LPOK ) WRITE(LP, 150) ' PARAORD_to_idCOMM'
    ENDIF
    CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &     id%COMM, id%MYID )
    IF (INFO(1).LT.0) GOTO 500
    CALL MUMPS_BUILD_PARAORD_to_idCOMM ( &
  &          id%COMM, id%MYID, id%KEEP(1), &
  &          COMM_PARASYMB, NPROCS_PARASYMB, &
  &          COMM_PARAORD, NPROCS_PARAORD, &
  &          PARAORD_to_idCOMM,
#if defined(AVOID_MPI_IN_PLACE)
  &          TMP,
#endif
  &          RKinSYMB_PROC0ORD, &
  &          RKinidCOMM_PROC0SYMB, id%NPROCS )
#if defined(AVOID_MPI_IN_PLACE)
    DEALLOCATE(TMP)
#endif
!
! 
!        build LUMAT such that col of LUMAT are distributed 
!        only procs in COMM_PARAORD
!        
    CALL MUMPS_AB_DCOORD_TO_DLUMAT ( &
  &          id%MYID, id%NPROCS, id%COMM, &
  &          NPROCS_PARAORD, PARAORD_to_idCOMM, &
  &          NBLK, id%N, &
  &          NNZ_loc, &
  &          IRN_loc_PTR(1), JCN_loc_PTR(1), &
  &          DOF2BLOCK(1), &
  &          id%ICNTL(1), id%INFO(1), id%KEEP(1), id%KEEP8(1), &
  &          LUMAT)
    IF (allocated(PARAORD_to_idCOMM)) THEN
     DEALLOCATE(PARAORD_to_idCOMM)
    ENDIF
    CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &        id%COMM, id%MYID )
    IF ( INFO(1) .LT. 0 ) GOTO 500
    LUMAT_AVAIL = .TRUE.
!         SIZEOFBLOCKS needed on all procs during // analysis
    CALL MPI_BCAST( SIZEOFBLOCKS, NBLK, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
!
!}    End of Parallel analysis
ELSE
!         ===================
!{        Sequential analysis
!         ===================
!         =======================
    IF (KEEP(54).NE.3.OR.id%NPROCS.EQ.1) THEN
!         =======================
!{        Matrix structure available on host
!         also case of distributed input matrix format 
!         with one mpi proc
!         ---------------------
     KEEP(14) = 0
     IF (id%MYID.EQ.MASTER) THEN
!            Store input matrix (IRN/JCN) as a cleaned blocked Lmatrix 
!            of nodes (indices \in [1,NBLK])
       IF (KEEP(54).NE.3) THEN
         IF (id%KEEP8(28) .EQ. 0_8) THEN
           IRN_PTR => IDUMMY_ARRAY
           JCN_PTR => IDUMMY_ARRAY
         ELSE
           IRN_PTR => id%IRN
           JCN_PTR => id%JCN
         ENDIF
         NNZ_TMP = id%KEEP8(28)
       ELSE
         IF (id%KEEP8(29) .EQ. 0_8) THEN ! NNZ_loc or NZ_loc
           IRN_PTR => IDUMMY_ARRAY
           JCN_PTR => IDUMMY_ARRAY
           id%KEEP8(29) = 0_8
         ELSE
           IRN_PTR => id%IRN_loc
           JCN_PTR => id%JCN_loc
         ENDIF
         NNZ_TMP = id%KEEP8(29)
       ENDIF
       CALL MUMPS_AB_COORD_TO_LMAT ( id%MYID, &
  &             NBLK, id%N, NNZ_TMP, IRN_PTR(1), JCN_PTR(1), &
  &             DOF2BLOCK, &
  &             INFO(1), INFO(2), LP, LPOK, &
  &             LMAT_BLOCK, IDUMMY8, KEEP(1) )
     ENDIF
     CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &        id%COMM, id%MYID )
     IF ( INFO(1) .LT. 0 ) GOTO 500
!         
     IF (id%MYID.EQ.MASTER) THEN
!            From LMAT_BLOCK build GCOMP format wich requires
!            symmetrizing the Lmatrix
       CALL MUMPS_AB_LMAT_TO_CLEAN_G ( id%MYID, .TRUE., &
  &            .TRUE., ! not relevant because unfold is true &
  &            LMAT_BLOCK, GCOMP, &
  &            INFO(1), ICNTL(1), MEMCNT)
       GCOMP_PROVIDED = .TRUE.
       IF (KEEP(494).EQ.0.OR.KEEP(487).NE.1) THEN
         CALL MUMPS_AB_FREE_LMAT(LMAT_BLOCK, KEEP(147))
         LMAT_BLOCK_AVAIL_I = 0
       ELSE
         LMAT_BLOCK_AVAIL_I = 1
       ENDIF
     ENDIF
     CALL MPI_BCAST( LMAT_BLOCK_AVAIL_I, 1, MPI_INTEGER, MASTER, &
  &                         id%COMM, IERR )
     LMAT_BLOCK_AVAIL = (LMAT_BLOCK_AVAIL_I.EQ.1)
!         
     CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &        id%COMM, id%MYID )
     IF ( INFO(1) .LT. 0 ) GOTO 500
!}
!         ====
    ELSE
!         ====
!         ----------------------
!{        matrix is distributed
!         ----------------------
      IF (.NOT. I_AM_SLAVE .OR. ! non-working master &
  &          id%KEEP8(29) .EQ. 0_8) THEN ! NNZ_loc or NZ_loc
!             Master non-working
        IRN_loc_PTR => IDUMMY_ARRAY
        JCN_loc_PTR => IDUMMY_ARRAY
        id%KEEP8(29) = 0_8
      ELSE
        IRN_loc_PTR => id%IRN_loc
        JCN_loc_PTR => id%JCN_loc
      ENDIF
!        
!           Given distributed matrix  IRN_loc_PTR, JCN_loc_PTR
!           build distributed cleaned graph GCOMP and
!           save  distributed LUMAT in case of grouping
!        
      IF (id%NPROCS.EQ.1) THEN
!             Build GCOMP, the centralized final cleaned graph
        READY_FOR_ANA_F = .TRUE.
        CALL MUMPS_AB_DCOORD_TO_DCOMPG ( &
  &             id%MYID, id%NPROCS, id%COMM, &
  &             NBLK, id%N, &
  &             id%KEEP8(29),  ! => NNZ_loc or NZ_loc &
  &             IRN_loc_PTR(1), JCN_loc_PTR(1), &
  &             DOF2BLOCK(1), &
  &             id%ICNTL(1), id%INFO(1), id%KEEP(1), &
  &             LUMAT, LUMAT_AVAIL, GCOMP, READY_FOR_ANA_F)
        GCOMP_PROVIDED = .TRUE.
      ELSE
        READY_FOR_ANA_F = .FALSE.
        CALL MUMPS_AB_DCOORD_TO_DCOMPG ( &
  &             id%MYID, id%NPROCS, id%COMM, &
  &             NBLK, id%N, &
  &             id%KEEP8(29),  ! => NNZ_loc or NZ_loc &
  &             IRN_loc_PTR(1), JCN_loc_PTR(1), &
  &             DOF2BLOCK(1), &
  &             id%ICNTL(1), id%INFO(1), id%KEEP(1), &
  &             LUMAT, LUMAT_AVAIL, GCOMP_DIST, READY_FOR_ANA_F)
      ENDIF
      IF (LUMAT_AVAIL.AND.KEEP(487).NE.1) THEN
         CALL MUMPS_AB_FREE_LMAT(LUMAT, KEEP(147))
         LUMAT_AVAIL = .FALSE.
      ENDIF
!        
!        
      CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &        id%COMM, id%MYID )
       IF ( INFO(1) .LT. 0 ) GOTO 500
!
!}        end matrix structure is distributed
!         =====
    ENDIF
!         =====
!}     end of sequential analysis
!      =====
 ENDIF
!      =====
 IF (allocated(DOF2BLOCK)) THEN
!        DOF2BLOCK reused on master if pivot order given by user
   IF ( (id%MYID.NE.MASTER) .OR. &
  &        (id%MYID.EQ.MASTER).AND. (KEEP(256) .NE. 1)) THEN
     DEALLOCATE(DOF2BLOCK)
   ENDIF
 ENDIF
!     ========================
ENDIF
!     } END preparation ANA_BLK
!     =========================
!     ====================================================
!     TEST FOR SEQUENTIAL OR PARALLEL ANALYSIS (KEEP(244))
!     ====================================================
IF ( (KEEP(244).EQ.1) .AND. (KEEP(54) .eq. 3) ) THEN
!     -----------------------------------------------
!     Sequential analysis: 
!     Collect on the host -- if matrix is distributed
!     at analysis -- all integer information needed
!     to perform ordering
!     -----------------------------------------------
! FIXME: one should test instead if GCOMP_DIST available 
!        instead of retestinf KEEP(13) and NPROCS.NE.1
    IF (KEEP(13).NE.0) THEN
     IF (id%NPROCS.NE.1) THEN
       CALL MUMPS_AB_GATHER_GRAPH( &
  &       id%ICNTL(1), KEEP(1), id%COMM, id%MYID, id%NPROCS, &
  &       id%INFO(1), &
  &       GCOMP_DIST, GCOMP)
       GCOMP_PROVIDED = .TRUE.
!
       CALL MUMPS_AB_FREE_GCOMP(GCOMP_DIST, MEMCNT)
     ENDIF
    ELSE
      CALL @MUMPS_PREFIX@MUMPS_GATHER_MATRIX(id)
      GATHER_MATRIX_ALLOCATED = .TRUE.
      CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &            id%COMM, id%MYID )
    ENDIF
    IF ( INFO(1) .LT. 0 ) GOTO 500
ENDIF
1234 CONTINUE
IF (KEEP(244) .EQ. 1) THEN
!     Sequential analysis : Schur
  IF ( id%MYID .eq. MASTER ) THEN
!           Prepare arguments for call to @MUMPS_PREFIX@MUMPS_ANA_F and
!           @MUMPS_PREFIX@MUMPS_ANA_F_ELT in case id%SCHUR was not allocated
!           by user. The objective is to avoid passing a null
!           pointer. 
! FIXME  Block fomat for Schur
      IF ( .NOT. associated( id%LISTVAR_SCHUR ) ) THEN
         SIZE_SCHUR_PASSED = 1
         LISTVAR_SCHUR_2BE_FREED=.TRUE.
         allocate( id%LISTVAR_SCHUR( 1 ), STAT=allocok )
         IF ( allocok .GT. 0 ) THEN
            WRITE(*,*) &
  &                 'PB allocating an array of size 1 for Schur!! '
            INFO(1)=-7
            INFO(2)=1
         END IF
      ELSE
         SIZE_SCHUR_PASSED=id%SIZE_SCHUR
         LISTVAR_SCHUR_2BE_FREED = .FALSE.
      END IF
  ENDIF
  CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &            id%COMM, id%MYID )
  IF ( INFO(1) < 0 ) GOTO 500
ENDIF
!
IF ((id%MYID.EQ.MASTER).AND.(KEEP(244) .EQ. 1) &
  &     .AND. (id%N.EQ.NBLK) &
  &   ) THEN
!     Sequential analysis : maximum transversal on master
   IF  ((KEEP(50).NE.1).AND. &
  &        .NOT.((KEEP(23).EQ.7).AND.KEEP(50).EQ.0) &
  &       ) THEN
!             (KEEP(23).EQ.7).AND.KEEP(50).EQ.0) :
!             For unsymmetric matrix, if automatic setting is requested
!             default setting of Maximum Transversal is decided during
!             @MUMPS_PREFIX@MUMPS_ANA_F and is based on matrix unsymmetry. 
!             Thus in this case we skip @MUMPS_PREFIX@MUMPS_ANA_O
        IF ( ( KEEP(23) .NE. 0 )  .OR.
!                Automatic choice for scaling does not force Maxtrans
!                Only when scaling is explicitly asked during analysis
!                (KEEP(52)=-2) @MUMPS_PREFIX@MUMPS_ANA_O is called
  &           KEEP(52) .EQ. -2 ) THEN
!
!                Maximum Trans. algorithm called on original matrix.
!                We compute a permutation of the original matrix to
!                have a zero free diagonal
!                KEEP(23)=7 means that automatic choice
!                      of max trans value will be done during analysis
!                Permutation is held in UNS_PERM(1, ...,N).  
!                Maximum transversal is not available for element 
!                entry format
!              UNS_PERM that might be set to
!              to permutation computed during Max transversal
         ALLOCATE(id%UNS_PERM(id%N),IKEEPALLOC(3_8*int(id%N,8)), &
  &                  WORK2ALLOC(id%N), stat=IERR)
         IF (IERR.GT.0) THEN
          INFO(1)=-7
          CALL MUMPS_SET_IERROR( 5_8 * int(id%N,8), INFO(2) )
         ELSE
          CALL @MUMPS_PREFIX@MUMPS_ANA_O(id%N, id%KEEP8(28), KEEP(23), &
  &              id%UNS_PERM, IKEEPALLOC, 3_8*int(id%N,8), &
  &              id%IRN, id%JCN, id%A, &
  &              id%ROWSCA, id%COLSCA, &
  &              WORK2ALLOC, id%KEEP, id%ICNTL, id%INFO, id%INFOG)
          IF (allocated(WORK2ALLOC)) DEALLOCATE(WORK2ALLOC)
          IF (KEEP(23).EQ.0) THEN
!                 Maximum tranversal did not produce a permutation
            IF (associated( id%UNS_PERM )) &
  &                    DEALLOCATE(id%UNS_PERM)
            NULLIFY(id%UNS_PERM)
          ENDIF
!               Check if IKEEPALLOC needed for ANA_F
          IF (KEEP(23).EQ.0.AND.(KEEP(95).EQ.1)) THEN
            IF (allocated(IKEEPALLOC)) DEALLOCATE(IKEEPALLOC)
          ENDIF
         ENDIF
         IF (INFO(1) .LT. 0) THEN
!              Fatal error
!              Permutation was not computed; reset keep(23)
            KEEP(23) = 0
         ELSE
         ENDIF
        ELSE
          KEEP(23)    = 0
!               Switch off
!               compressed/contrained ordering
          id%KEEP(95) = 1
        END IF
   ENDIF
!     END OF MAX-TRANS ON THE MASTER
ENDIF
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), id%COMM, id%MYID )
IF ( INFO(1) < 0 ) GOTO 500
!
IF ( KEEP(244) .EQ. 1) THEN
!        Sequential analysis: allocate data for ordering on MASTER
   IF (id%MYID.EQ.MASTER) THEN
!          allocate IKEEPALLOC and TREE related pointers
!          IKEEPALLOC might have been allocated in @MUMPS_PREFIX@MUMPS_ANA_O
!          and IKEEPALLOC(1:N) might hold information to 
!          be given to ANA_F.
     IF (allocated(IKEEPALLOC)) THEN
       ALLOCATE( FILS_TMP(NBLK), FREREPTR(NBLK), &
  &               NFSIZPTR(NBLK), stat=IERR)
       IF (IERR.GT.0) THEN
        INFO(1)=-7
        CALL MUMPS_SET_IERROR(int(NBLK,8)*3_8, INFO(2))
       ENDIF
     ELSE
       ALLOCATE(IKEEPALLOC(int(NBLK,8)+2_8*int(id%N,8)), &
  &               FILS_TMP(NBLK), FREREPTR(NBLK), &
  &               NFSIZPTR(NBLK), stat=IERR)
      IF (IERR.GT.0) THEN
       INFO(1)=-7
       CALL MUMPS_SET_IERROR(int(NBLK,8)*4_8+2_8*int(id%N,8), &
  &            INFO(2))
      ENDIF
     ENDIF
   ENDIF
   CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), id%COMM, id%MYID )
   IF ( INFO(1) < 0 ) GOTO 500
ENDIF
!
IF (KEEP(244) .EQ. 1) THEN
!     Sequential analysis
  IF ( id%MYID .eq. MASTER ) THEN
!       BEGINNING OF ANALYSIS ON THE MASTER
!       ------------------------------------------------------
!       For element entry (KEEP(55).ne.0), we do not know NZ, 
!       and so the whole allocation of IW cannot be done at this 
!       point and more workspace is declared/allocated/used
!       inside @MUMPS_PREFIX@MUMPS_ANA_F_ELT.
!       ------------------------------------------------------
!
      IF (KEEP(55) .EQ. 0) THEN
!              ----------------
!              Assembled format
!              ----------------
         NZ8=id%KEEP8(28)
!              Compute LIW8:
!              For local orderings a contiguous space IW 
!              of size LIW8 must be provided. 
!              IW must hold the graph (with double adjacency 
!              list) and and extra space of size the number of 
!              nodes in the graph: 
!                ==>   LIW8 = 2_8 * NZ8 +  int(NBLK,8) + 1_8
!              In case of analysis by block and 
!              However, when GCOMP is provided directly then 
!              IW is not allocated 
!                ==>   LIW8 = 0
!              In this case 
!                size(LCOMP%ADJ)>= 2_8*NZ8+int(NBLK,8)+1_8 
!                should hold
         IF (KEEP(13).NE.0) THEN
!                Compact graph is provided on entry to @MUMPS_PREFIX@MUMPS_ANA_F
           NZ8=0_8 ! GCOMP is provided on entry
         ENDIF
         IF (NZ8.EQ.0_8) THEN
           LIW8 = 0_8
         ELSE
           LIW8 = 2_8 * NZ8 +  int(NBLK,8) + 1_8
         ENDIF
!        
      ELSE
!              ----------------
!              Elemental format
!              ----------------
!              Only available for AMD, METIS, and given ordering
#if defined(metis) || defined(parmetis) || defined(metis4) || defined(parmetis3)
         COND = (KEEP(60) .NE. 0) .OR. (KEEP(256) .EQ. 5)
#else
         COND = (KEEP(60) .NE. 0)
#endif
         IF( COND ) THEN
!
!
!                 we suppress supervariable detection when Schur
!                 is active or when METIS is applied
!                 Workspaces for FLAG(N), and either LEN(N) or some pointers(N+1)
            LIW8_ELT = int(id%N,8) + int(id%N,8) + 1_8
         ELSE
!                 Spaces FLAG(N), LEN(N), N+3, SVAR(0:N),
            LIW8_ELT =  int(id%N,8) + int(id%N,8) + &
  &                       int(id%N,8)+3_8 + int(id%N,8)+1_8
         ENDIF
!     
      ENDIF
!           We must ensure that an array of order
!           3*N is available for @MUMPS_PREFIX@MUMPS_ANA_LNEW
      IF (KEEP(55) .EQ. 0) THEN
        IF (LIW8.LT.3_8*int(NBLK,8)) LIW8=3_8*int(NBLK,8)
      ELSE
        IF (LIW8_ELT.LT.3_8*int(id%N,8)) LIW8_ELT=3_8*int(id%N,8)
      ENDIF
!
      IF ( KEEP(256) .EQ. 1 ) THEN
!            It has been checked that id%PERM_IN is associated but
!            values of pivot order will be checked later and
!            should be checked here too
!            PERM_IN( I ) = position of I in the pivot order
       IKEEP2 => IKEEPALLOC(int(NBLK+1,8):int(NBLK,8)+int(id%N,8))
!            Build inverse permutation and check PERM_IN 
       DO I = 1, id%N
          IKEEP2(I) = 0
       ENDDO
       DO I = 1, id%N
          IF ( id%PERM_IN(I) .LT.1 .OR. &
  &               id%PERM_IN(I) .GT. id%N ) THEN
!                 PERM_IN entry is out-of-range
            INFO(1) = -4
            INFO(2) = I
            GOTO 10
          ELSE IF ( IKEEP2(id%PERM_IN(I)) .NE. 0 ) THEN
!                 Duplicate entry in PERM_IN was found
            INFO(1) = -4
            INFO(2) = I
            GOTO 10
          ELSE
!                 Store entry in inverse permutation
            IKEEP2(id%PERM_IN( I )) = I
          ENDIF
       ENDDO
       IF ((KEEP(55) .EQ. 0).AND.(KEEP(13).NE.0) &
  &           .AND.(KEEP(13).NE.-1) &
  &         ) THEN
!             Build blocked permutation:
!              IKEEPALLOC(IB)= IBPos where IB, IBPos \in [1:NBLK]
!             IKEEP2 holds inverse permutation
        IPOSB = 0
        IPOS  = 1
        DO WHILE (IPOS.LE.id%N)
          IPOSB     = IPOSB+1
          I         = IKEEP2(IPOS)
          IBcurrent = DOF2BLOCK(I)
          BLKSIZE   = SIZEOFBLOCKS(IBcurrent)
          IKEEPALLOC(IBcurrent) = IPOSB
          IF (BLKSIZE.GT.1) THEN
           DO II = 1, BLKSIZE-1
            IPOS    = IPOS+1
            I       = IKEEP2(IPOS)
            IB      = DOF2BLOCK(I)
            IF (IB.NE.IBcurrent) THEN
             IF (PROKG) THEN
              WRITE(MPG,'(A,A)') &
  &               " ERROR: given permutation (ICNTL(7)=1)", &
  &               " incompatible with block format"
             ENDIF
             INFO(1)= -4
             INFO(2)= I
             GOTO 10
            ENDIF
           ENDDO
          ENDIF
          IPOS = IPOS+1
        ENDDO
!             IF PERM_IN is correct then
!             on exit last position should be NBLK
        IF (IPOSB.NE.NBLK) THEN
             IF (PROKG) THEN
              WRITE(MPG,'(A,A)') &
  &               " ERROR: given permutation (ICNTL(7)=1)", &
  &               " incompatible with block format"
             ENDIF
             INFO(1)= -4
!                  N+1 to indicate "global" error
             INFO(2)= id%N+1
             GOTO 10
        ENDIF
       ELSE
         DO I = 1, id%N
            IKEEPALLOC( I ) = id%PERM_IN( I )
         END DO
       ENDIF
       IF (allocated(DOF2BLOCK)) DEALLOCATE(DOF2BLOCK)
      END IF
      INFOG(1) = 0
      INFOG(2) = 0
!           Initialize structural symmetry value to not yet computed.
      INFOG(8) = -1
      IF (KEEP(55) .EQ. 0) THEN
         IKEEP1 => IKEEPALLOC(1:NBLK)
         IKEEP2 => IKEEPALLOC(int(NBLK+1,8): &
  &                              int(NBLK,8)+int(id%N,8))
         IKEEP3 => IKEEPALLOC(int(NBLK,8)+int(id%N+1,8): &
  &                              int(NBLK,8)+2_8*int(id%N,8))
!              id%UNS_PERM corresponds to argument PIV
!              in @MUMPS_PREFIX@MUMPS_ANA_F, it should be an assumed-shape
!              array rather than a possibly null pointer:
         IF (associated(id%UNS_PERM)) THEN
           UNS_PERM_PTR => id%UNS_PERM
         ELSE
           UNS_PERM_PTR => IDUMMY_ARRAY
         ENDIF
         IF (KEEP(13).EQ.0) THEN
          CALL @MUMPS_PREFIX@MUMPS_ANA_F(id%N, NZ8, &
  &              id%IRN, id%JCN, &
  &              LIW8, IKEEP1, IKEEP2, IKEEP3, &
  &              KEEP(256), NFSIZPTR, &
  &              FILS_TMP, &
  &              FREREPTR, &
  &              id%LISTVAR_SCHUR, SIZE_SCHUR_PASSED, &
  &              id%ICNTL, id%INFOG, id%KEEP,id%KEEP8,id%NSLAVES, &
  &              UNS_PERM_PTR, &
  &              id%CNTL(4), id%COLSCA,  id%ROWSCA
#if defined(metis) || defined(parmetis) || defined(metis4) || defined(parmetis3)         
  &              , id%METIS_OPTIONS(1)
#endif               
  &          )
         ELSE
          IRN_loc_PTR => IDUMMY_ARRAY
          JCN_loc_PTR => IDUMMY_ARRAY
          CALL @MUMPS_PREFIX@MUMPS_ANA_F(NBLK, NZ8, &
  &              IRN_loc_PTR, JCN_loc_PTR, &
  &              LIW8, IKEEP1, IKEEP2, IKEEP3, &
  &              KEEP(256), NFSIZPTR, &
  &              FILS_TMP, FREREPTR, &
  &              id%LISTVAR_SCHUR, SIZE_SCHUR_PASSED, &
  &              id%ICNTL, id%INFOG, id%KEEP,id%KEEP8,id%NSLAVES, &
  &              UNS_PERM_PTR, &
  &              id%CNTL(4), id%COLSCA,  id%ROWSCA
#if defined(metis) || defined(parmetis) || defined(metis4) || defined(parmetis3)         
  &              , id%METIS_OPTIONS(1)
#endif               
  &              , id%N, SIZEOFBLOCKS, GCOMP_PROVIDED, GCOMP &
  &          )
          IF (GCOMP_PROVIDED) &
  &              CALL MUMPS_AB_FREE_GCOMP(GCOMP, MEMCNT)
!
         ENDIF
         INFOG(7)     = KEEP(256)
!              UNS_PERM_PTR was only used locally
!              for the call to @MUMPS_PREFIX@MUMPS_ANA_F
         NULLIFY(UNS_PERM_PTR)
      ELSE
         allocate( XNODEL ( id%N+1 ), stat = IERR )
         IF ( IERR .GT. 0 ) THEN
            INFO( 1 ) = -7
            INFO( 2 ) = id%N + 1
            IF ( LPOK ) THEN
               WRITE(LP, 150) 'XNODEL'
            END IF
            GOTO 10
         ENDIF
         IF (LELTVAR.ne.id%ELTPTR(NELT+1)-1)  THEN
!     -- internal error
            INFO(1) = -2002
            INFO(2) = id%ELTPTR(NELT+1)-1
            GOTO 10
         ENDIF
         allocate( NODEL ( LELTVAR ), stat = IERR )
         IF ( IERR .GT. 0 ) THEN
            INFO( 1 ) = -7
            INFO( 2 ) = LELTVAR
            IF ( LPOK ) THEN
               WRITE(LP, 150) 'NODEL'
            END IF
            GOTO 10
         ENDIF
         CALL @MUMPS_PREFIX@MUMPS_ANA_F_ELT(id%N, NELT, &
  &              id%ELTPTR(1), id%ELTVAR(1), LIW8_ELT, &
  &              IKEEPALLOC(1), &
  &              KEEP(256), NFSIZPTR(1), FILS_TMP(1), &
  &              FREREPTR(1), id%LISTVAR_SCHUR(1), &
  &              SIZE_SCHUR_PASSED, &
  &              ICNTL(1), INFOG(1), KEEP(1),KEEP8(1), &
  &              id%NSLAVES, &
  &              XNODEL(1), NODEL(1)
#if defined(metis) || defined(parmetis) || defined(metis4) || defined(parmetis3)         
  &              , id%METIS_OPTIONS(1)
#endif               
  &          )
         INFOG(7)=KEEP(256)
!     
!              XNODEL and NODEL as output to @MUMPS_PREFIX@MUMPS_ANA_F_ELT 
!              be used in @MUMPS_PREFIX@MUMPS_FRTELT and thus 
!              cannot be deallocated at this point
!     
      ENDIF
      IF ( LISTVAR_SCHUR_2BE_FREED ) THEN
!              We do not want to have LISTVAR_SCHUR
!              allocated of size 1 if Schur is off. 
         DEALLOCATE( id%LISTVAR_SCHUR )
         NULLIFY   ( id%LISTVAR_SCHUR )
         LISTVAR_SCHUR_2BE_FREED = .TRUE.
      ENDIF
!           ------------------------------
!           Significant error codes should
!           always be in INFO(1/2)
!           ------------------------------
      INFO(1)=INFOG(1)
      INFO(2)=INFOG(2)
!           save statistics in KEEP array.
      KEEP(28) = INFOG(6)
      IKEEP = 1_8
      NA      = IKEEP +       int(id%N,8)
      NE      = IKEEP + 2_8 * int(id%N,8)
!       -- if (id%myid.eq.master)
  ENDIF
!       -- if sequential analysis
ENDIF
!
10 CONTINUE
IF (KEEP(244).EQ.1) THEN
   CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), id%COMM, id%MYID )
   IF ( INFO(1) < 0 ) GOTO 500
ENDIF
IF ((KEEP(244).EQ.1).AND.(KEEP(55).EQ.0)) THEN
!     Sequential analysis on assembled matrix
!     check if  max transversal should be called
  CALL MPI_BCAST(KEEP(23),1,MPI_INTEGER,MASTER,id%COMM,IERR)
  IF ( (KEEP(23).LE.-1).AND.(KEEP(23).GE.-6) ) THEN
!          -- Perform max transversal
     KEEP(23) = -KEEP(23)
     IF (id%MYID.EQ.MASTER) THEN
       IF (.NOT. associated(id%A)) KEEP(23) = 1
       IF (associated(id%UNS_PERM)) DEALLOCATE(id%UNS_PERM)
       NULLIFY(id%UNS_PERM)
       IF (allocated(IKEEPALLOC)) DEALLOCATE(IKEEPALLOC)
       IF (allocated(FILS_TMP) ) THEN
         DEALLOCATE(FILS_TMP)
       ENDIF
       IF (associated(FREREPTR) ) THEN
         DEALLOCATE(FREREPTR)
         NULLIFY(FREREPTR)
       ENDIF
       IF (associated(NFSIZPTR) ) THEN
         DEALLOCATE(NFSIZPTR)
         NULLIFY(NFSIZPTR)
       ENDIF
     ENDIF
  GOTO 1234
  ENDIF
ENDIF
IF (id%MYID.EQ.MASTER) THEN
  IF ((KEEP(244).EQ.1).AND. (KEEP(55).EQ.0))  THEN
!              Sequential ordering on assembled matrix
         IF ((KEEP(54).EQ.3).AND.KEEP(494).EQ.0) THEN
           IF (GATHER_MATRIX_ALLOCATED) THEN
              IF (associated(id%IRN)) THEN
                DEALLOCATE(id%IRN)
                NULLIFY(id%IRN)
              ENDIF
              IF (associated(id%JCN)) THEN
                DEALLOCATE(id%JCN)
                NULLIFY(id%JCN)
              ENDIF
              GATHER_MATRIX_ALLOCATED= .FALSE.
           ENDIF
         ENDIF
  ENDIF
ENDIF
IF (KEEP(244).NE.1) THEN
!{    Parallel analysis
   IF (id%MYID .EQ. MASTER) THEN
!             KEEPALLOC reuse later 
!             FIXME allocate of size 2*NBLK and 
!                   allocate of size 3*id%N after call ana_aux_par
        SIZEIKEEPALLOC = 3_8*int(id%N,8)
        SIZEWORK2ALLOC = max(4_8*int(NBLK,8), int(id%NPROCS+1,8))
      ALLOCATE( IKEEPALLOC(SIZEIKEEPALLOC), &
  &                WORK2ALLOC(SIZEWORK2ALLOC), &
  &                FILS_TMP(NBLK), FREREPTR(NBLK), NFSIZPTR(NBLK), &
  &      stat=IERR)
   ELSE IF (COMM_PARASYMB.NE.MPI_COMM_NULL) THEN
!           Allocate only on procs concerned by parallel analysis
      SIZEIKEEPALLOC = 3_8*int(NBLK,8)
      SIZEWORK2ALLOC = 4_8*int(NBLK,8)
      ALLOCATE(IKEEPALLOC(SIZEIKEEPALLOC), &
  &               WORK2ALLOC(SIZEWORK2ALLOC), stat=IERR )
   ELSE
!           Not concerned by @MUMPS_PREFIX@MUMPS_ANA_F_PAR
      IERR = 0
      SIZEIKEEPALLOC = 0_8
      SIZEWORK2ALLOC = 0_8
   ENDIF
   IF (IERR.GT.0) THEN
     INFO(1) = -7
     IF (id%MYID .EQ. MASTER) THEN
       CALL MUMPS_SET_IERROR( &
  &            SIZEIKEEPALLOC+SIZEWORK2ALLOC+3_8*int(NBLK,8), &
  &            INFO(2) )
     ELSE
       CALL MUMPS_SET_IERROR( &
  &            SIZEIKEEPALLOC+SIZEWORK2ALLOC, &
  &            INFO(2) )
     ENDIF
   ENDIF
   CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), id%COMM, id%MYID )
   IF ( INFO(1) < 0 ) GOTO 500
!        save value provided by user
   idNBLKSAVE= id%NBLK
!
#if defined(MUMPS_NOF2003)
!        Allocatable not allowed in @MUMPS_PREFIX@MUMPS_ANA_F_PAR,
!        use a pointer instead. FILS_TMP is typically
!        allocated only on MPI rank 0.
   IF (allocated(FILS_TMP)) THEN
     FILS_TMPPTR => FILS_TMP
   ELSE
     FILS_TMPPTR => IDUMMY_ARRAY
   ENDIF
#endif
   IF (LUMAT_AVAIL) THEN
!{
!             
     id%NBLK   = NBLK
     IF (COMM_PARASYMB.NE.MPI_COMM_NULL) THEN
      IF (RKinidCOMM_PROC0SYMB.NE.MASTER) CALL MUMPS_ABORT()
      CALL @MUMPS_PREFIX@MUMPS_ANA_F_PAR(id, &
  &        IKEEPALLOC, &
  &        WORK2ALLOC, &
  &        SIZEIKEEPALLOC, &
  &        SIZEWORK2ALLOC, &
  &        NFSIZPTR,
#if defined(MUMPS_NOF2003)
  &        FILS_TMPPTR,
#else
  &        FILS_TMP,
#endif
  &        FREREPTR, &
  &        COMM_PARASYMB
!    optional:
  &        , LUMAT, SIZEOFBLOCKS &
  &        , COMM_PARAORD, NPROCS_PARAORD &
  &        , RKinSYMB_PROC0ORD &
  & )
     ENDIF
     IF (KEEP(494).EQ.0.OR.KEEP(487).NE.1) THEN
      CALL MUMPS_AB_FREE_LMAT(LUMAT,KEEP(147))
      LUMAT_AVAIL = .FALSE.
     ELSE
      LUMAT_AVAIL = .TRUE.
     ENDIF
!
!}
   ELSE
!{         LUMAT not available and COMM_PARASYMB=id%COMM
     id%NBLK   = id%N
     CALL @MUMPS_PREFIX@MUMPS_ANA_F_PAR(id, &
  &        IKEEPALLOC, &
  &        WORK2ALLOC, &
  &        SIZEIKEEPALLOC, &
  &        SIZEWORK2ALLOC, &
  &        NFSIZPTR,
#if defined(MUMPS_NOF2003)
  &        FILS_TMPPTR,
#else
  &        FILS_TMP,
#endif
  &        FREREPTR, &
  &        id%COMM &
  & )
!}
   ENDIF
   id%NBLK = idNBLKSAVE
   IF (COMM_PARASYMB.NE.MPI_COMM_NULL) THEN
      DEALLOCATE(WORK2ALLOC)
      IF(id%MYID .NE. MASTER) THEN
        DEALLOCATE(IKEEPALLOC)
      ENDIF
   ENDIF
   KEEP(28) = INFOG(6)
   IF (COMM_PARAORD_ALLOCATED) THEN
     IF (COMM_PARAORD.NE.MPI_COMM_NULL) THEN
       CALL MPI_COMM_FREE( COMM_PARAORD, IERR )
       COMM_PARAORD_ALLOCATED = .FALSE.
     ENDIF
   ENDIF
   IF (COMM_PARASYMB_ALLOCATED) THEN
     IF (COMM_PARASYMB.NE.MPI_COMM_NULL) THEN
       CALL MPI_COMM_FREE( COMM_PARASYMB, IERR )
       COMM_PARASYMB_ALLOCATED = .FALSE.
     ENDIF
   ENDIF
!        Check error after freeing communicators
   CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), id%COMM, id%MYID )
   IF ( INFO(1) < 0 ) GOTO 500
!
   IF (id%MYID.EQ.MASTER) THEN
     IKEEP   = 1_8
     NA      = IKEEP +       int(id%N,8)
     NE      = IKEEP + 2_8 * int(id%N,8)
   ENDIF
!        ---------------------------------------------------------
!        Check whether FILS_TMP, FREREPTR, NFSIZPTR
!        computed on master of COMM_PARSYMB (RKinidCOMM_PROC0SYMB)
!        should be send on MASTER 
!        ---------------------------------------------------------
   IF (RKinidCOMM_PROC0SYMB.NE.MASTER) THEN
!             allocate data on MASTER of id%COMM
        IF (id%MYID.EQ.MASTER) THEN
!              FILS_TMP allocate to size NBLK since it will be 
!              allways copied back in structure
         ALLOCATE( FILS_TMP(NBLK), FREREPTR(id%N), NFSIZPTR(id%N), &
  &                stat=IERR)
        ENDIF
    ENDIF
    IF (IERR.GT.0) THEN
     INFO(1) = -7
     IF (id%MYID .EQ. MASTER) THEN
       CALL MUMPS_SET_IERROR(3_8*int(id%N,8), INFO(2))
     ENDIF
   ENDIF
   CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), id%COMM, id%MYID )
   IF ( INFO(1) < 0 ) GOTO 500
   IF (RKinidCOMM_PROC0SYMB.NE.MASTER) THEN
!             data computed on master of COMM_PARASYMB to be 
!             sent on MASTER of id%COMM
!             FIXME to be authorized INFOG data should also
!             be sent to MASTER of id%COMM
        CALL MUMPS_ABORT()
        IF (id%MYID.EQ.RKinidCOMM_PROC0SYMB) THEN
          CALL MPI_SEND (FILS_TMP(1), NBLK, MPI_INTEGER, &
  &               MASTER, CENT_AFTER_PARAORD, id%COMM, IERR)
          CALL MPI_SEND (FREREPTR(1), NBLK, MPI_INTEGER, &
  &               MASTER, CENT_AFTER_PARAORD, id%COMM, IERR)
          CALL MPI_SEND (NFSIZPTR(1), NBLK, MPI_INTEGER, &
  &               MASTER, CENT_AFTER_PARAORD, id%COMM, IERR)
!
!               deallocate data sent to MASTER
          DEALLOCATE(FILS_TMP, FREREPTR, NFSIZPTR)
!               FILS_TMP is an allocatable array
          nullify(FREREPTR, NFSIZPTR)
!
        ENDIF
        IF (id%MYID.EQ.MASTER) THEN
          CALL MPI_RECV (FILS_TMP(1), NBLK, MPI_INTEGER, &
  &               RKinidCOMM_PROC0SYMB, CENT_AFTER_PARAORD, &
  &               id%COMM, STATUS, IERR)
          CALL MPI_RECV (FREREPTR(1), NBLK, MPI_INTEGER, &
  &               RKinidCOMM_PROC0SYMB, CENT_AFTER_PARAORD, &
  &               id%COMM, STATUS, IERR)
          CALL MPI_RECV (NFSIZPTR(1), NBLK, MPI_INTEGER, &
  &               RKinidCOMM_PROC0SYMB, CENT_AFTER_PARAORD, &
  &               id%COMM, STATUS, IERR)
        ENDIF
!
   ENDIF
!}
END IF
!     Allocated PROCNODE on MASTER
IF (id%MYID.EQ.MASTER) THEN
 allocok = 0
 allocate(PROCNODE(NBLK), STAT=allocok)
 IF (allocok .ne. 0) THEN
      INFO(1) = -7
      INFO(2) = NBLK
 ENDIF
ENDIF
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), id%COMM, id%MYID )
IF ( INFO(1) < 0 ) GOTO 500
IF ( I_AM_SLAVE) THEN
      KEEP(144)=1 ! MPI process is working
ELSE
  KEEP(144)=0
ENDIF
IF(id%MYID .EQ. MASTER) THEN
!        Save ICNTL(14) value into KEEP(12)
   CALL MUMPS_GET_PERLU(KEEP(12),ICNTL(14), &
  &        KEEP(50),KEEP(54),ICNTL(6),KEEP(52))
   CALL @MUMPS_PREFIX@MUMPS_ANA_R(NBLK, FILS_TMP(1), FREREPTR(1), &
  &        IKEEPALLOC(NE), IKEEPALLOC(NA))
!      **********************************************************
!      Continue with CALL to MAPPING routine
!        *********************
!        BEGIN SEQUENTIAL CODE
!        No mapping computed
!        *********************
!
!        In sequential, if no special root
!        reset KEEP(20) and KEEP(38) to 0
!
   IF (id%NSLAVES .EQ. 1 &
  &      ) THEN
      id%NBSA = 0
      IF ( (id%KEEP(60).EQ.0). &
  &           AND.(id%KEEP(53).EQ.0))  THEN
!     If Schur is on (keep(60).ne.0)
!     or if RR is on (keep (53) > 0 
!     then we keep root numbers
!              root node number in seq  
         id%KEEP(20)=0
!              root node number in paral  
         id%KEEP(38)=0
      ENDIF
!     No type 2 nodes:
      id%KEEP(56)=0
!     All mapped on MPI process 0, and of type TPN=0
!     (treated as if they were all root of subtree)
      PROCNODE_VALUE = MUMPS_ENCODE_TPN_IPROC(0, 0, KEEP(199))
      DO I = 1, NBLK
        PROCNODE(I) = PROCNODE_VALUE
      END DO
!     It may also happen that KEEP(38) has already been set,
!     in the case of a distributed Schur complement (KEEP(60)=2 or 3).
!     In that case, PROCNODE should be set accordingly and KEEP(38) is
!     not modified.
      IF (id%KEEP(60) .EQ. 2 .OR. id%KEEP(60).EQ.3) THEN
         PROCNODE_VALUE = MUMPS_ENCODE_TPN_IPROC(3, 0, KEEP(199))
         CALL @MUMPS_PREFIX@MUMPS_SET_PROCNODE(id%KEEP(38), PROCNODE(1), &
  &              PROCNODE_VALUE, FILS_TMP(1), NBLK)
      ENDIF
!        *******************
!        END SEQUENTIAL CODE
!        *******************
   ELSE
!        *****************************
!        BEGIN MAPPING WITH CANDIDATES
!        (NSLAVES > 1)
!        *****************************
!     
!     
!      peak is set by default to 1 largest front + One largest CB
 PEAK = @MUMPS_REAL_CONV@(id%INFOG(5))*@MUMPS_REAL_CONV@(id%INFOG(5)) + ! front matrix &
  &        @MUMPS_REAL_CONV@(id%KEEP(2))*@MUMPS_REAL_CONV@(id%KEEP(2))     ! cb bloc
!     IKEEP(1:N,1) can be used as a work space since it is set
!     to its final state by the SORT_PERM subroutine below.
      SSARBR => IKEEPALLOC(IKEEP:IKEEP+int(NBLK-1,8))
!     ======================================================
!     Map nodes and assign candidates for dynamic scheduling
!     ======================================================
IF ((KEEP(13).NE.0).AND.(NBLK.NE.id%N)) THEN
 SIZEOFBLOCKS_PTR => SIZEOFBLOCKS(1:NBLK)
 LSIZEOFBLOCKS_PTR = NBLK
ELSE
 SIZEOFBLOCKS_PTR => IDUMMY_ARRAY
 LSIZEOFBLOCKS_PTR = 1
 IDUMMY_ARRAY(1) = -1
ENDIF
      CALL @MUMPS_PREFIX@MUMPS_DIST_AVOID_COPIES( &
  &           NBLK,id%NSLAVES,ICNTL(1), &
  &           INFOG(1), &
  &           IKEEPALLOC(NE), &
  &           NFSIZPTR(1), &
  &           FREREPTR(1), &
  &           FILS_TMP(1), &
  &           KEEP(1),KEEP8(1),PROCNODE(1), &
  &           SSARBR(1),id%NBSA,PEAK,IERR &
  &           , SIZEOFBLOCKS_PTR(1), LSIZEOFBLOCKS_PTR &
  &           )
      NULLIFY(SSARBR)
      if(IERR.eq.-999) then
         write(6,*) ' Internal error during static mapping '
         INFO(1) = IERR
         GOTO 11
      ENDIF
      IF(IERR.NE.0) THEN
         INFO(1) = -135
         INFO(2) = IERR
         GOTO 11
      ENDIF
      CALL @MUMPS_PREFIX@MUMPS_ANA_R(NBLK, FILS_TMP(1), &
  &           FREREPTR(1), IKEEPALLOC(NE), &
  &           IKEEPALLOC(NA))
   ENDIF
11    CONTINUE
ENDIF
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), id%COMM, id%MYID )
IF ( INFO(1) < 0 ) GOTO 500
!     The following part is done in parallel
CALL MPI_BCAST( id%NELT, 1, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
IF (KEEP(55) .EQ. 0) THEN
!     Assembled matrix format. Fill up the id%PTRAR array
!     Broadcast id%SYM_PERM needed to fill up id%PTRAR
!     postpone to after computation  of id%SYM_PERM 
!     computed after id%DAD_STEPS
   if (associated(id%FRTPTR)) DEALLOCATE(id%FRTPTR)
   if (associated(id%FRTELT)) DEALLOCATE(id%FRTELT)
   allocate( id%FRTPTR(1), id%FRTELT(1) ,STAT=allocok)
   IF (allocok .GT. 0) THEN
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'FRTPTR,FRTELT'
      END IF
      INFO(1)= -7
      INFO(2)= 2
   END IF
ELSE
!     Element Entry: 
!     -------------------------------
!     COMPUTE THE LIST OF ELEMENTS THAT WILL BE ASSEMBLED
!     AT EACH NODE OF THE ELIMINATION TREE. ALSO COMPUTE
!     FOR EACH ELEMENT THE TREE NODE TO WHICH IT IS ASSIGNED.
!     
!     FRTPTR is an INTEGER array of length N+1 which need not be set by
!     the user. On output, FRTPTR(I) points in FRTELT to first element 
!     in the list of elements assigned to node I in the elimination tree.
!     
!     FRTELT is an INTEGER array of length NELT which need not be set by
!     the user. On output, positions FRTELT(FRTPTR(I)) to
!     FRTELT(FRTPTR(I+1)-1) contain the list of elements assigned to 
!     node I in the elimination tree.
!     
   LPTRAR = id%NELT+id%NELT+2
   CALL MUMPS_I8REALLOC(id%PTRAR, LPTRAR, id%INFO, LP, &
  &        FORCE=.TRUE., STRING='id%PTRAR (Analysis)', ERRCODE=-7)
   CALL MUMPS_REALLOC(id%FRTPTR, id%N+1, id%INFO, LP, &
  &        FORCE=.TRUE., STRING='id%FRTPTR (Analysis)', ERRCODE=-7)
   CALL MUMPS_REALLOC(id%ELTPROC, id%NELT, id%INFO, LP, &
  &        FORCE=.TRUE., STRING='id%ELTPROC (Analysis)', ERRCODE=-7)
   CALL MUMPS_REALLOC(id%FRTELT, id%NELT, id%INFO, LP, &
  &        FORCE=.TRUE., STRING='id%FRTELT (Analysis)', ERRCODE=-7)
   CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), id%COMM, id%MYID )
   IF ( INFO(1) < 0 ) GOTO 500
   IF(id%MYID .EQ. MASTER) THEN
!     In the elemental format case, PTRAR&friends are still
!     computed sequentially and then broadcasted
      CALL @MUMPS_PREFIX@MUMPS_FRTELT( &
  &           id%N, NELT, id%ELTPTR(NELT+1)-1, FREREPTR(1), &
  &           FILS_TMP(1), &
  &           IKEEPALLOC(NA), IKEEPALLOC(NE), XNODEL, &
  &           NODEL, id%FRTPTR(1), id%FRTELT(1), id%ELTPROC(1))
      DO I=1, id%NELT+1
!              PTRAR declared 64-bit
         id%PTRAR(id%NELT+I+1)=int(id%ELTPTR(I),8)
      ENDDO
      DEALLOCATE(XNODEL)
      DEALLOCATE(NODEL)
   END IF
   CALL MPI_BCAST( id%PTRAR(id%NELT+2), id%NELT+1, MPI_INTEGER8, &
  &        MASTER, id%COMM, IERR )
   CALL MPI_BCAST( id%FRTPTR(1), id%N+1, MPI_INTEGER, &
  &        MASTER, id%COMM, IERR )
   CALL MPI_BCAST( id%FRTELT(1), id%NELT,  MPI_INTEGER, &
  &        MASTER, id%COMM, IERR )
ENDIF
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), id%COMM, id%MYID )
IF ( INFO(1) < 0 ) GOTO 500
!     We switch again to sequential computations on the master node
IF(id%MYID .EQ. MASTER) THEN
   IF ( INFO( 1 ) .LT. 0 ) GOTO 12
   IF ( KEEP(55) .ne. 0 ) THEN
!        ---------------------------------------
!        Build ELTPROC: correspondance between elements and slave ranks
!        in COMM_NODES with special values -1 (all procs) and -2 and -3
!        (no procs). This is used later to distribute the elements on
!        the processes at the beginning of the factorisation phase
!        ---------------------------------------
      CALL @MUMPS_PREFIX@MUMPS_ELTPROC(NBLK, NELT, id%ELTPROC(1),id%NSLAVES, &
  &           PROCNODE(1), id%KEEP(1))
   END IF
   NB_NIV2 = KEEP(56)
   IF ( NB_NIV2.GT.0 ) THEN
!     
      allocate(PAR2_NODES(NB_NIV2), &
  &           STAT=allocok)
      IF (allocok .GT.0) then
         INFO(1)= -7
         INFO(2)= NB_NIV2
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'PAR2_NODES'
         END IF
         GOTO 12
      END IF
   ENDIF
   IF ((NB_NIV2.GT.0) .AND. (KEEP(24).EQ.0)) THEN
      INIV2 = 0
      DO 777 INODE = 1, NBLK
         IF ( ( FREREPTR(INODE) .NE. NBLK ) .AND. &
  &              ( MUMPS_TYPENODE(PROCNODE(INODE),id%KEEP(199)) &
  &              .eq. 2) ) THEN
            INIV2 = INIV2 + 1
            PAR2_NODES(INIV2) = INODE
         END IF
777       CONTINUE
      IF ( INIV2 .NE. NB_NIV2 ) THEN
         WRITE(*,*) "Internal Error 2 in @MUMPS_PREFIX@MUMPS_ANA_DRIVER", &
  &              INIV2, NB_NIV2
         CALL MUMPS_ABORT()
      ENDIF
   ENDIF
   IF ( (KEEP(24) .NE. 0) .AND. (NB_NIV2.GT.0) ) THEN
!           allocate array to store cadidates stategy
!           for each level two nodes
      IF ( associated(id%CANDIDATES)) DEALLOCATE(id%CANDIDATES)
      allocate( id%CANDIDATES(id%NSLAVES+1,NB_NIV2), &
  &           stat=allocok)
      if (allocok .gt.0) then
         INFO(1)= -7
         INFO(2)= NB_NIV2*(id%NSLAVES+1)
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'CANDIDATES'
         END IF
         GOTO 12
      END IF
      CALL MUMPS_RETURN_CANDIDATES &
  &           (PAR2_NODES,id%CANDIDATES, &
  &            IERR)
      IF(IERR.NE.0)  THEN
         INFO(1) = -2002
         GOTO 12
      ENDIF
!     deallocation of variables of module mumps_static_mapping
      CALL MUMPS_END_ARCH_CV()
      IF(IERR.NE.0)  THEN
         INFO(1) = -2002
         GOTO 12
      ENDIF
   ELSE
      IF (associated(id%CANDIDATES)) DEALLOCATE(id%CANDIDATES)
      allocate(id%CANDIDATES(1,1), stat=allocok)
      IF (allocok .NE. 0) THEN
         INFO(1)= -7
         INFO(2)= 1
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'CANDIDATES'
         END IF
         GOTO 12
      ENDIF
   ENDIF
!*******************************************************************
!     ---------------
12    CONTINUE
!     ---------------
!     
!     ===============================
!     End of analysis phase on master
!     ===============================
!     
END IF
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), id%COMM, id%MYID )
IF ( INFO(1) < 0 ) GOTO 500
!     
!     We now allocate and compute arrays in NSTEPS
!     on the master, as this makes more sense.
!     
!     Broadcast KEEP8(101) to be used in MUMPS_ANA_L0_OMP
CALL MPI_BCAST( id%KEEP8(101), 1, MPI_INTEGER8, MASTER, &
  &     id%COMM, IERR )
!
!     ==============================
!     PREPARE DATA FOR FACTORIZATION
!     ==============================
!     ------------------
CALL MPI_BCAST( id%KEEP(1), 110, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
!     We also need to broadcast KEEP8(21) 
CALL MPI_BCAST( id%KEEP8(21), 1, MPI_INTEGER8, MASTER, &
  &     id%COMM, IERR )
!     --------------------------------------------------
!     Broadcast KEEP(205) which is outside the first 110
!     KEEP entries but is needed for factorization.
!     --------------------------------------------------
CALL MPI_BCAST( id%KEEP(205), 1, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
!     --------------
!     Broadcast NBSA 
CALL MPI_BCAST( id%NBSA, 1, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
!     -----------------
!     Global MAXFRT (computed in @MUMPS_PREFIX@MUMPS_ANA_M)
!     is needed on all the procs during @MUMPS_PREFIX@MUMPS_ANA_DISTM
!     to evaluate workspace for solve. 
!     We could also recompute it in @MUMPS_PREFIX@MUMPS_ANA_DISTM
IF (id%MYID==MASTER) KEEP(127)=INFOG(5)
CALL MPI_BCAST( id%KEEP(127), 1, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
!     -----------------
!     Global max panel size KEEP(226)
CALL MPI_BCAST( id%KEEP(226), 1, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
!     -----------------
CALL MPI_BCAST( id%KEEP(464), 2, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
CALL MPI_BCAST( id%KEEP(471), 2, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
CALL MPI_BCAST( id%KEEP(475), 1, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
CALL MPI_BCAST( id%KEEP(482), 1, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
CALL MPI_BCAST( id%KEEP(487), 2, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
!     Number of leaves not belonging to L0 KEEP(262)
!              and KEEP(263) : inner or outer sends for blocked facto
CALL MPI_BCAST( id%KEEP(262), 2, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
!     ----------------------------------------
!     Allocate new workspace on all processors
!     ----------------------------------------
!     STEP_TMP is of size NBLK because it 
!                is computed on compressed graph and 
!                broadcasted when needed.
!                It is then extended in id%STEP on master
!                and broadcasted on all procs
ALLOCATE(STEP_TMP(NBLK),  stat=IERR)
IF (IERR.GT.0) THEN
     INFO(1)=-7
     INFO(2)=NBLK
ENDIF
IF(INFO(1).LT.0) GOTO 94
CALL MUMPS_REALLOC(id%PROCNODE_STEPS, id%KEEP(28), id%INFO, LP, &
  &     FORCE=.TRUE., &
  &     STRING='id%PROCNODE_STEPS (Analysis)', ERRCODE=-7)
IF(INFO(1).LT.0) GOTO 94
CALL MUMPS_REALLOC(id%NE_STEPS, id%KEEP(28), id%INFO, LP, &
  &     FORCE=.TRUE., &
  &     STRING='id%NE_STEPS (Analysis)', ERRCODE=-7)
IF(INFO(1).LT.0) GOTO 94
CALL MUMPS_REALLOC(id%ND_STEPS, id%KEEP(28), id%INFO, LP, &
  &     FORCE=.TRUE., &
  &     STRING='id%ND_STEPS (Analysis)', ERRCODE=-7)
IF(INFO(1).LT.0) GOTO 94
CALL MUMPS_REALLOC(id%FRERE_STEPS, id%KEEP(28), id%INFO, LP, &
  &     FORCE=.TRUE., &
  &     STRING='id%FRERE_STEPS (Analysis)', ERRCODE=-7)
IF(INFO(1).LT.0) GOTO 94
CALL MUMPS_REALLOC(id%DAD_STEPS, id%KEEP(28), id%INFO, LP, &
  &     FORCE=.TRUE., &
  &     STRING='id%DAD_STEPS (Analysis)', ERRCODE=-7)
IF(INFO(1).LT.0) GOTO 94
IF (KEEP(55) .EQ. 0) THEN
  LPTRAR = 2
  CALL MUMPS_I8REALLOC(id%PTRAR, LPTRAR, id%INFO, LP, &
  &       FORCE=.TRUE., STRING='id%PTRAR (Analysis)', ERRCODE=-7)
  IF(INFO(1).LT.0) GOTO 94
ENDIF
IF (id%KEEP(494).NE.0) THEN
!       of size NBLK that will be extended and copies later
!       on master
  SIZELRGROUPS_TMP = NBLK
ELSE
!       needed as argument for @MUMPS_PREFIX@MUMPS_EXPAND_TREE_STEPS
  SIZELRGROUPS_TMP = 1
ENDIF
ALLOCATE(LRGROUPS_TMP(SIZELRGROUPS_TMP),  stat=IERR)
IF (IERR.GT.0) THEN
     INFO(1)=-7
     INFO(2)=NBLK
ENDIF
!
IF(INFO(1).LT.0) GOTO 94
!     Copy data for factorization and/or solve.
!     ================================
!     COMPUTE ON THE MASTER, BROADCAST
!     TO OTHER PROCESSES
!     ================================
IF ( id%MYID .NE. MASTER .OR. id%KEEP(23) .EQ. 0 ) THEN
 IF ( associated( id%UNS_PERM ) ) THEN
   DEALLOCATE(id%UNS_PERM)
 ENDIF
ENDIF
94 CONTINUE
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &     id%COMM, id%MYID )
IF ( id%MYID .EQ. MASTER ) THEN
!     NA -> compressed NA containing only list
!     of leaves of the elimination tree and list of roots 
!     (the two useful informations for factorization/solve).
   IF (NBLK.eq.1) THEN
      NBROOT = 1
      NBLEAF = 1
   ELSE IF (IKEEPALLOC(NA+int(NBLK-1,8)) .LT.0) THEN
      NBLEAF= NBLK
      NBROOT= NBLK
   ELSE IF (IKEEPALLOC(NA+int(NBLK-2,8)) .LT.0) THEN
      NBLEAF = NBLK-1
      NBROOT = IKEEPALLOC(NA+int(NBLK-1,8))
   ELSE
      NBLEAF = IKEEPALLOC(NA+int(NBLK-2,8))
      NBROOT = IKEEPALLOC(NA+int(NBLK-1,8))
   ENDIF
   id%LNA = 2+NBLEAF+NBROOT
ENDIF
CALL MPI_BCAST( id%LNA, 1, MPI_INTEGER, &
  &     MASTER, id%COMM, IERR )
CALL MUMPS_REALLOC(id%NA, id%LNA, id%INFO, LP, FORCE=.TRUE., &
  &     STRING='id%NA (Analysis)', ERRCODE=-7)
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &     id%COMM, id%MYID )
IF ( INFO(1).LT.0 ) GOTO 500
IF (id%MYID .EQ.MASTER ) THEN
!{    The structure of NA is the following:
!        NA(1) is the number of leaves.
!        NA(2) is the number of roots.
!        NA(3:2+NA(1)) are the leaves.
!        NA(3+NA(1):2+NA(1)+NA(2)) are the roots.
   id%NA(1) = NBLEAF
   id%NA(2) = NBROOT
!     
!        Initialize NA with the leaves and roots
   LEAF = 3
   IF ( NBLK == 1 ) THEN
      id%NA(LEAF) = 1
      LEAF = LEAF + 1
   ELSE IF (IKEEPALLOC(NA+int(NBLK-1,8)) < 0) THEN
      id%NA(LEAF) = - IKEEPALLOC(NA+int(NBLK-1,8))-1
      LEAF = LEAF + 1
      DO I = 1, NBLEAF - 1
         id%NA(LEAF) = IKEEPALLOC(NA+int(I-1,8))
         LEAF = LEAF + 1
      ENDDO
   ELSE IF (IKEEPALLOC(NA+int(NBLK-2,8)) < 0 ) THEN
      INODE = - IKEEPALLOC(NA+int(NBLK-2,8)) - 1
      id%NA(LEAF) = INODE
      LEAF =LEAF + 1
      IF ( NBLEAF > 1 ) THEN
         DO I = 1, NBLEAF - 1
            id%NA(LEAF) = IKEEPALLOC(NA+int(I-1,8))
            LEAF = LEAF + 1
         ENDDO
      ENDIF
   ELSE
      DO I = 1, NBLEAF
         id%NA(LEAF) = IKEEPALLOC(NA+int(I-1,8))
         LEAF = LEAF + 1
      ENDDO
   END IF
!
!        Build array STEP_TMP(1:NBLK) to hold step numbers in
!        range 1..id%KEEP(28), allowing compression of
!        other arrays from id%N to id%KEEP(28)
!        (the number of nodes/steps in the assembly tree)
   ISTEP = 0
   DO I = 1, NBLK
      IF ( FREREPTR(I) .ne. NBLK + 1 ) THEN
!        New node in the tree.
!        (Set step( inode_n ) = inode_nsteps for principal
!        variables and -inode_nsteps for internal variables
!        of the node)
         ISTEP = ISTEP + 1
         STEP_TMP(I)=ISTEP
         INN = FILS_TMP(I)
         DO WHILE ( INN .GT. 0 )
            STEP_TMP(INN) = - ISTEP
            INN = FILS_TMP(INN)
         END DO
         IF (FREREPTR(I) .eq. 0) THEN
!              Keep root nodes list in NA
            id%NA(LEAF) = I
            LEAF = LEAF + 1
         ENDIF
      ENDIF
   END DO
   IF ( LEAF - 1 .NE. 2+NBROOT + NBLEAF ) THEN
      WRITE(*,*) 'Internal error 2 in @MUMPS_PREFIX@MUMPS_ANA_DRIVER'
      CALL MUMPS_ABORT()
   ENDIF
   IF ( ISTEP .NE. id%KEEP(28) ) THEN
      write(*,*) 'Internal error 3 in @MUMPS_PREFIX@MUMPS_ANA_DRIVER', &
  &        ISTEP, id%KEEP(28)
      CALL MUMPS_ABORT()
   ENDIF
!        ============
!        SET PROCNODE, FRERE, NE
!        ============
!        copies to NSTEP array should be ok
   DO I = 1, NBLK
      IF (FREREPTR(I) .NE. NBLK+1) THEN
         id%PROCNODE_STEPS(STEP_TMP(I)) = PROCNODE( I )
         id%FRERE_STEPS(STEP_TMP(I))    = FREREPTR(I)
         id%NE_STEPS(STEP_TMP(I)) = IKEEPALLOC(NE+int(I-1,8))
         id%ND_STEPS(STEP_TMP(I)) = NFSIZPTR(I)
      ENDIF
   ENDDO
!        ===============================
!        Algorithm to compute array DAD_STEPS:
!        ----
!        For each node set dad for all of its sons
!        plus, for root nodes set dad to zero.
!     
!        ===============================
   DO I = 1, NBLK
!     -- skip non principal nodes
      IF ( STEP_TMP(I) .LE. 0) CYCLE
!     -- (I) is a principal node
      IF (FREREPTR(I) .eq. 0) THEN
!     -- I is a root node and has no father
         id%DAD_STEPS(STEP_TMP(I)) = 0
      ENDIF
!     -- Find first son node (IFS)
      IFS = FILS_TMP(I)
      DO WHILE ( IFS .GT. 0 )
         IFS= FILS_TMP(IFS)
      END DO
!     -- IFS > 0 if I is not a leave node
!     -- Go through list of brothers of IFS if any
      IFS = -IFS
      DO WHILE (IFS.GT.0)
!     -- I is not a leave node and has a son node IFS
         id%DAD_STEPS(STEP_TMP(IFS)) = I
         IFS   = FREREPTR(IFS)
      ENDDO
   END DO
!
!     
!        Following arrays (PROCNODE and IKEEPALLOC) not used anymore 
!        during analysis
   IF (allocated(PROCNODE)) DEALLOCATE(PROCNODE)
   IF (allocated(IKEEPALLOC)) DEALLOCATE(IKEEPALLOC)
   IF (associated(FREREPTR)) DEALLOCATE(FREREPTR)
   NULLIFY(FREREPTR)
   IF (associated(NFSIZPTR)) DEALLOCATE(NFSIZPTR)
   NULLIFY(NFSIZPTR)
ENDIF
IF (KEEP(494).NE.0) THEN
!{
   IF (id%MYID.EQ.MASTER) THEN
      IF (PROKG) THEN
            CALL MUMPS_SECDEB(TIMEG)
      END IF
   ENDIF
!     =======================================================
!     Compute a grouping of variables for LR approximations.
!     Grouping may be performed on a distributed matrix
!     =======================================================
!     
!     =======================================
!     I/ Prepare data before call to grouping
!     =======================================
  LUMAT_REMAP_DIST_AVAIL = .FALSE.
  LUMAT_REMAP_CENT_AVAIL = .FALSE.
!
  IF (LUMAT_AVAIL) THEN
!         Use clean symmetrized LUMAT matrix available 
    ALLOCATE(MAPCOL(id%KEEP(28)), stat=allocok)
    IF (allocok .ne.0) then
     INFO(1)= -7
     INFO(2)= id%KEEP(28)
    ENDIF
!         Broadcast errors
    CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &      id%COMM, id%MYID )
    IF ( INFO(1).LT.0 ) GOTO 500
!
    CALL MUMPS_INIALIZE_REDIST_LUMAT ( &
  &     id%INFO, id%ICNTL, id%KEEP, id%COMM, id%MYID, NBLK, &
  &     id%NPROCS, &
  &     LUMAT, id%PROCNODE_STEPS(1), id%KEEP(28), MAPCOL, &
  &     LUMAT_REMAP, NBRECORDS, STEP_TMP(1))
!         INFO(1) has been broadcasted already in routine
    IF ( id%INFO(1).LT.0 ) GOTO 500
!
!         -- Redistribute LUMAT into LU_REMAP relying on procnode
    CALL MUMPS_AB_DIST_LMAT_TO_LUMAT ( &
  &      .FALSE., ! do not UNFOLD &
  &      .TRUE.,  ! MAPCOL in NSTEPS=> STEP array needed &
  &      id%INFO, id%ICNTL, id%COMM, id%MYID, NBLK, id%NPROCS, &
  &      LUMAT, MAPCOL, id%KEEP(28), STEP_TMP(1), NBLK, &
  &      LUMAT_REMAP, NBRECORDS, NSEND8, NLOCAL8 &
  &     )
     LUMAT_REMAP_DIST_AVAIL = .TRUE.
    CALL MUMPS_AB_FREE_LMAT(LUMAT,KEEP(147))
!         Distribute SIZEOFBLOCKS that was defined only on master
    CALL MPI_BCAST( SIZEOFBLOCKS, NBLK, MPI_INTEGER, MASTER, &
  &     id%COMM, IERR )
!}
  ELSE IF ( LMAT_BLOCK_AVAIL ) THEN
!{        Centralized matrix and clean LMAT_BLOCK available
!        
    IF (id%MYID.EQ.MASTER) THEN
!
     CALL MUMPS_AB_CLEANLMAT_TO_LUMAT ( &
  &              LMAT_BLOCK, LUMAT_REMAP, KEEP(147), &
  &              INFO(1), ICNTL(1))
     LUMAT_REMAP_CENT_AVAIL=.TRUE.
!            --- LMAT_BLOCK not needed anymore
     CALL MUMPS_AB_FREE_LMAT(LMAT_BLOCK,KEEP(147))
!
    ENDIF
!         Broadcast errors
    CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &      id%COMM, id%MYID )
    IF ( INFO(1).LT.0 ) GOTO 500
!}
  ELSE IF ((KEEP(54).EQ.3).AND.(KEEP(13).EQ.0) &
  &           .AND. KEEP(487).EQ.1) THEN
!{
!        Matrix is distributed on entry and compression not requested
!        (this will be the case when ICNTL(15).EQ.0 and 
!         // analysis, or Schur, etc...)
!        note that with distributed matrix and centralized ordering
!        compression is forced to limit memory peak)
!        Free centralized matrix before grouping to 
!        limit memory peak
   IF (GATHER_MATRIX_ALLOCATED) THEN
       IF (associated(id%IRN)) THEN
                DEALLOCATE(id%IRN)
                NULLIFY(id%IRN)
       ENDIF
       IF (associated(id%JCN)) THEN
                DEALLOCATE(id%JCN)
                NULLIFY(id%JCN)
       ENDIF
       GATHER_MATRIX_ALLOCATED= .FALSE.
   ENDIF
   IF (.NOT. I_AM_SLAVE .OR. ! non-working master &
  &       id%KEEP8(29) .EQ. 0_8) THEN ! NNZ_loc or NZ_loc
!          Master non-working
     IRN_loc_PTR => IDUMMY_ARRAY
     JCN_loc_PTR => IDUMMY_ARRAY
   ELSE
     IRN_loc_PTR => id%IRN_loc
     JCN_loc_PTR => id%JCN_loc
   ENDIF
   ALLOCATE(MAPCOL(id%KEEP(28)), stat=allocok)
   IF (allocok .ne.0) then
     INFO(1)= -7
     INFO(2)= id%KEEP(28)
   ENDIF
!        Broadcast errors
   CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &      id%COMM, id%MYID )
   IF ( INFO(1).LT.0 ) GOTO 500
!
!        Build MAPCOL and LUMAT_REMAP mapped according 
!        to MAPCOL (outputs available on all MPI procs).
   CALL MUMPS_AB_DCOORD_TO_DTREE_LUMAT ( &
  &          id%MYID, id%NPROCS, id%COMM, &
  &          NBLK, id%N, &
  &          id%KEEP8(29),  ! => NNZ_loc or NZ_loc &
  &          IRN_loc_PTR(1), JCN_loc_PTR(1), &
  &          id%PROCNODE_STEPS(1), id%KEEP(28), STEP_TMP(1), &
  &          id%ICNTL(1), id%INFO(1), id%KEEP(1), &
  &          MAPCOL, LUMAT_REMAP )
   LUMAT_REMAP_DIST_AVAIL = .TRUE.
   IF (INFO(1).GE.0) THEN
!         SIZEOFBLOCKS needed on all procs during MPI grouping
    ALLOCATE(SIZEOFBLOCKS(NBLK), stat=allocok)
    IF (allocok .ne.0) then
     INFO(1)= -7
     INFO(2)= NBLK
    ENDIF
    DO I=1, NBLK
      SIZEOFBLOCKS(I) = 1
    ENDDO
   ENDIF
!        Broadcast errors
   CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &      id%COMM, id%MYID )
   IF ( INFO(1).LT.0 ) GOTO 500
!}
  ELSE IF ((KEEP(54).EQ.3) .AND. (KEEP(487).NE.1) &
  &     ) THEN
!{
!        Grouping preparation on slaves:
!        If the input matrix is distributed 
!        the graph is centralized to compute the
!        clustering. 
!
      CALL @MUMPS_PREFIX@MUMPS_GATHER_MATRIX(id)
      GATHER_MATRIX_ALLOCATED = .TRUE.
!}
  ENDIF
!     ============
!     ============
!     II/ GROUPING
!     ============
  IF (LUMAT_REMAP_DIST_AVAIL) THEN
!{        Distributed memory based grouping is used
    IF (id%MYID.NE.MASTER) THEN
      ALLOCATE(FILS_TMP(NBLK), stat=IERR)
      IF (IERR.GT.0) THEN
       INFO(1)=-7
       INFO(2)=NBLK
      ENDIF
    ENDIF
!         Broadcast errors
    CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &      id%COMM, id%MYID )
    IF ( INFO(1).LT.0 ) GOTO 500
    CALL MPI_BCAST( id%ND_STEPS(1), KEEP(28), MPI_INTEGER, &
  &    MASTER, id%COMM, IERR )
    CALL @MUMPS_PREFIX@MUMPS_AB_LR_MPI_GROUPING(NBLK, &
  &           MAPCOL, id%KEEP(28), &
  &           id%KEEP(28), LUMAT_REMAP, FILS_TMP(1), &
  &           id%FRERE_STEPS, &
  &           id%DAD_STEPS, STEP_TMP(1), id%NA, &
  &           id%LNA, LRGROUPS_TMP(1), SIZEOFBLOCKS(1), id%KEEP(50), &
  &           id%ICNTL(1), id%KEEP(487), id%KEEP(488), &
  &           id%KEEP(490), id%KEEP(38), id%KEEP(20), id%KEEP(60), &
  &           id%INFO(1), id%INFO(2), &
  &           id%KEEP(264), id%KEEP(265), id%KEEP(482), id%KEEP(472), &
  &           id%KEEP(127), id%KEEP(469), id%KEEP(10), &
  &           id%KEEP(54), id%KEEP(142), &
  &           LPOK, LP, id%COMM, id%MYID, id%NPROCS, &
  &           id%KEEP(1), id%ND_STEPS)
    IF (allocated(MAPCOL)) DEALLOCATE(MAPCOL)
    IF (id%MYID.NE.MASTER) DEALLOCATE(FILS_TMP)
!}
  ELSE IF (id%MYID.EQ.MASTER) THEN
!{
      IF (LUMAT_REMAP_CENT_AVAIL) THEN
!{
!
       IDUMMY_ARRAY(1) = -1
         CALL @MUMPS_PREFIX@MUMPS_AB_LR_MPI_GROUPING(NBLK, &
  &           IDUMMY_ARRAY, 1, &
  &           id%KEEP(28), LUMAT_REMAP, FILS_TMP, &
  &           id%FRERE_STEPS, &
  &           id%DAD_STEPS, STEP_TMP, id%NA, &
  &           id%LNA, LRGROUPS_TMP, SIZEOFBLOCKS(1), id%KEEP(50), &
  &           id%ICNTL(1), id%KEEP(487), id%KEEP(488), &
  &           id%KEEP(490), id%KEEP(38), id%KEEP(20), id%KEEP(60), &
  &           id%INFO(1), id%INFO(2), &
  &           id%KEEP(264), id%KEEP(265), id%KEEP(482), id%KEEP(472), &
  &           id%KEEP(127), id%KEEP(469), id%KEEP(10), &
  &           id%KEEP(54), id%KEEP(142), &
  &           LPOK, LP, id%COMM, id%MYID, id%NPROCS, &
  &           id%KEEP(1), id%ND_STEPS)
!}
      ELSE
!{           grouping based on centralized matrix
       IF (KEEP(469).EQ.0) THEN
         CALL @MUMPS_PREFIX@MUMPS_LR_GROUPING(id%N, id%KEEP8(28), id%KEEP(28), &
  &           id%IRN, &
  &           id%JCN, FILS_TMP, id%FRERE_STEPS, &
  &           id%DAD_STEPS, id%NE_STEPS, STEP_TMP, id%NA, &
  &           id%LNA, LRGROUPS_TMP, &
  &           id%KEEP(50), &
  &           id%ICNTL(1), id%KEEP(487), id%KEEP(488), &
  &           id%KEEP(490), id%KEEP(38), id%KEEP(20), id%KEEP(60), &
  &           id%INFO(1), id%INFO(2), &
  &           id%KEEP(264), id%KEEP(265), id%KEEP(482), id%KEEP(472), &
  &           id%KEEP(127), id%KEEP(10), &
  &           id%KEEP(54), id%KEEP(142), &
  &           LPOK, LP, GATHER_MATRIX_ALLOCATED, &
  &           id%KEEP(1), id%ND_STEPS)
       ELSE
         CALL @MUMPS_PREFIX@MUMPS_LR_GROUPING_NEW(id%N, id%KEEP8(28), &
  &           id%KEEP(28), id%IRN, &
  &           id%JCN, FILS_TMP, id%FRERE_STEPS, &
  &           id%DAD_STEPS, STEP_TMP, id%NA, &
  &           id%LNA, LRGROUPS_TMP, id%KEEP(50), &
  &           id%ICNTL(1), id%KEEP(487), id%KEEP(488), &
  &           id%KEEP(490), id%KEEP(38), id%KEEP(20), id%KEEP(60), &
  &           id%INFO(1), id%INFO(2), &
  &           id%KEEP(264), id%KEEP(265), id%KEEP(482), id%KEEP(472), &
  &           id%KEEP(127), id%KEEP(469), id%KEEP(10), &
  &           id%KEEP(54), id%KEEP(142), &
  &           LPOK, LP, GATHER_MATRIX_ALLOCATED, &
  &           id%KEEP(1), id%ND_STEPS)
       ENDIF
!}
      ENDIF
!}
  ENDIF
!       Broadcast errors 
  CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &      id%COMM, id%MYID )
  IF ( INFO(1).LT.0 ) GOTO 500
!       update KEEP(142): maximum group size
  CALL MPI_BCAST( KEEP(142), 1, MPI_INTEGER, MASTER, &
  &                      id%COMM, IERR )
!     ============
!     III/ CLEANUP 
!     ============
!       Free LUMAT_REMAP if allocated
  IF (LUMAT_REMAP_DIST_AVAIL.OR.LUMAT_REMAP_CENT_AVAIL) &
  &      CALL MUMPS_AB_FREE_LMAT(LUMAT_REMAP,KEEP(147))
  IF (allocated(MAPCOL)) DEALLOCATE(MAPCOL)
  IF (allocated(SIZEOFBLOCKS)) DEALLOCATE(SIZEOFBLOCKS)
  IF ( (KEEP(54).EQ.3) .AND. (KEEP(244).EQ.2).AND. &
  &       (KEEP(487).NE.1) ) THEN
!           Cleanup the irn and jcn arrays filled up by the
!           @MUMPS_PREFIX_LOWER@mumps_gather_matrix above. It might have been done
!           during grouping
      IF (GATHER_MATRIX_ALLOCATED) THEN
          IF (associated(id%IRN)) THEN
            DEALLOCATE(id%IRN)
            NULLIFY(id%IRN)
          ENDIF
          IF (associated(id%JCN)) THEN
            DEALLOCATE(id%JCN)
            NULLIFY(id%JCN)
          ENDIF
          GATHER_MATRIX_ALLOCATED= .FALSE.
      ENDIF
  END IF
  IF (PROKG) THEN
    CALL MUMPS_SECFIN(TIMEG)
    WRITE(MPG,145) TIMEG
  END IF
!}    Grouping: KEEP(494) .NE. 0
ENDIF
!     ALLOCATE id%FILS(id%N)on all procs possibly using mpi3
  CALL MUMPS_REALLOC(id%FILS, id%N, id%INFO, LP, FORCE=.TRUE., &
  &     STRING='id%FILS (Analysis)', ERRCODE=-7)
  IF(INFO(1).LT.0) GOTO 97
!
!     ALLOCATE id%STEP(id%N)on all procs possibly using mpi3
  CALL MUMPS_REALLOC(id%STEP, id%N, id%INFO, LP, FORCE=.TRUE., &
  &     STRING='id%STEP (Analysis)', ERRCODE=-7)
  IF(INFO(1).LT.0) GOTO 97
!
!     ALLOCATE id%LRGROUPS on all procs possibly using mpi3
!     compute size of id%LRGROUPS in KEEP(280)
IF (id%KEEP(494).EQ.0) THEN
!      not used
 id%KEEP(280) = 1
ELSE
 id%KEEP(280) = id%N
ENDIF
  CALL MUMPS_REALLOC(id%LRGROUPS, id%KEEP(280), id%INFO, LP, &
  &     FORCE=.TRUE., &
  &     STRING='id%LRGROUPS (Analysis)', ERRCODE=-7)
  IF(INFO(1).LT.0) GOTO 97
IF (id%MYID.EQ.MASTER) THEN
!{
  IF (KEEP(13).NE.0) THEN
!{      ===========
!       Expand tree  
!       ===========
!       Current tree is relative to the analysis by block.
!       Expand the tree on the master if compression is effective
!       (in all cases, grouping done or not)
    IF (NBLK.LT.id%N.OR.(.NOT.BLKVAR_ALLOCATED)) THEN
!         {
!         even if NBLK.EQ.N BLKVAR provided by user might hold
!         a permutation of the variables and this expand_tree_steps 
!         should also be called
!           Expand FILS_TMP, STEP_TMP into id%FILS, id%STEP
!           and update arrays of size NSTEPS
      IF (NB_NIV2.EQ.0) THEN
         IDUMMY_ARRAY(1)   = -9999
         PAR2_NODESPTR     => IDUMMY_ARRAY(1:1)
         SIZE_PAR2_NODESPTR=1
      ELSE
         PAR2_NODESPTR => PAR2_NODES(1:NB_NIV2)
         SIZE_PAR2_NODESPTR=NB_NIV2
      ENDIF
      CALL MUMPS_REALLOC(id%FILS, id%N, id%INFO, LP, &
  &           FORCE=.TRUE., &
  &           STRING='id%FILS (Analysis)', ERRCODE=-7)
      IF(INFO(1).LT.0) GOTO 97
      CALL @MUMPS_PREFIX@MUMPS_EXPAND_TREE_STEPS (id%ICNTL, &
  &        id%N, NBLK, BLKPTR_PTRLOC(1), BLKVAR_PTRLOC(1), &
  &        FILS_TMP(1), id%FILS(1), id%KEEP(28), &
  &        STEP_TMP(1), id%STEP(1), &
  &        PAR2_NODESPTR(1), SIZE_PAR2_NODESPTR, &
  &        id%DAD_STEPS(1), id%FRERE_STEPS(1), &
  &        id%NA(1), id%LNA, &
  &        LRGROUPS_TMP(1), SIZELRGROUPS_TMP, &
  &        id%LRGROUPS(1), KEEP(280), &
  &        id%KEEP(20), id%KEEP(38), KEEP(494) &
  &           )
      NULLIFY(PAR2_NODESPTR)
!
!         }
    ELSE
!{           NBLK=N
!            perform local copies
       DO I=1, NBLK
         id%STEP(I) = STEP_TMP(I)
         id%FILS(I) = FILS_TMP(I)
       ENDDO
       IF (id%KEEP(494).NE.0) THEN
        DO I=1, id%KEEP(280)
         id%LRGROUPS(I) = LRGROUPS_TMP(I)
        ENDDO
       ENDIF
!}
    ENDIF
!}
  ELSE
!{        NBLK=N
!         perform local copies
    DO I=1, NBLK
      id%STEP(I) = STEP_TMP(I)
      id%FILS(I) = FILS_TMP(I)
    ENDDO
    IF (id%KEEP(494).NE.0) THEN
!          we copy only in case of BLR since
!          LRGROUPS_TMP is otherwise allocated
!          and not used/initialized
     DO I=1, id%KEEP(280)
      id%LRGROUPS(I) = LRGROUPS_TMP(I)
     ENDDO
    ENDIF
!}
  ENDIF
!
!       -------------------------------------------
!       Adjust LR_GROUPING to bound size of groups 
!       and update KEEP(142): maximum group size
!       that should then be broadcasted again
!       -------------------------------------------
  IF (id%N.GT.NBLK.AND.KEEP(494).NE.0) THEN
    CALL MUMPS_ADJUST_SIZE_LRGROUPS ( &
  &     id%STEP(1), id%FILS(1), id%N, &
  &     id%ND_STEPS(1), id%KEEP(28), id%KEEP(1), &
  &     id%LRGROUPS(1), INFO(1), INFO(2))
   ENDIF
!}
ENDIF
!     update KEEP(142): maximum group size that might have been
!     updated in MUMPS_ADJUST_SIZE_LRGROUPS
CALL MPI_BCAST( KEEP(142), 1, MPI_INTEGER, MASTER, &
  &                      id%COMM, IERR )
!
97 CONTINUE
!
IF (allocated(STEP_TMP)) DEALLOCATE(STEP_TMP)
IF (allocated(LRGROUPS_TMP)) DEALLOCATE(LRGROUPS_TMP)
IF (allocated(FILS_TMP)) DEALLOCATE(FILS_TMP)
!
!
  CALL MUMPS_REALLOC(id%SYM_PERM, id%N, id%INFO, LP, &
  &  FORCE=.TRUE., &
  &  STRING='id%SYM_PERM (Analysis)', ERRCODE=-7)
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), id%COMM, id%MYID )
IF ( INFO(1) < 0 ) GOTO 500
IF (id%MYID.EQ.MASTER) THEN
!     =================================================================
!     Reorder the tree using a variant of Liu's algorithm. Note that
!     REORDER_TREE MUST always be called since it sorts NA (the list of
!     leaves) in a valid order in the sense of a depth-first traversal.
!     =================================================================
         CALL @MUMPS_PREFIX@MUMPS_REORDER_TREE(id%N, id%FRERE_STEPS(1), &
  &              id%STEP(1),id%FILS(1), id%NA(1), id%LNA, &
  &              id%NE_STEPS(1), id%ND_STEPS(1), id%DAD_STEPS(1), &
  &              id%KEEP(28), .TRUE., id%KEEP(28), id%KEEP(70), &
  &              id%KEEP(50), id%INFO(1), id%ICNTL(1),id%KEEP(215), &
  &              id%KEEP(234), id%KEEP(55), id%KEEP(199), &
  &              id%PROCNODE_STEPS(1),id%NSLAVES,PEAK,id%KEEP(90) &
  &              )
      IF(id%KEEP(261).EQ.1)THEN
         CALL MUMPS_SORT_STEP(id%N, id%FRERE_STEPS(1), &
  &              id%STEP(1),id%FILS(1), id%NA(1), id%LNA, &
  &              id%NE_STEPS(1), id%ND_STEPS(1), id%DAD_STEPS(1), &
  &              id%KEEP(28), .TRUE., id%KEEP(28), id%INFO(1), &
  &              id%ICNTL(1),id%PROCNODE_STEPS(1),id%NSLAVES &
  &              )
      ENDIF
!     Compute and export some global information on the tree needed by
!     dynamic schedulers during the factorization. The type of
!     information depends on the selected strategy.
   IF ((id%KEEP(76).GE.4).OR.(id%KEEP(76).GE.6).OR. &
  &              (id%KEEP(47).EQ.4).OR.((id%KEEP(81).GT.0) &
  &              .AND.(id%KEEP(47).GE.2)))THEN
      IS_BUILD_LOAD_MEM_CALLED=.TRUE.
      IF ((id%KEEP(47) .EQ. 4).OR. &
  &           (( id%KEEP(81) .GT. 0).AND.(id%KEEP(47).GE.2))) THEN
         IF(id%NSLAVES.GT.1) THEN
!                 NBSA is the total number of subtrees  and
!                 is an upperbound of the local number of
!                 subtrees
            SIZE_TEMP_MEM = id%NBSA
         ELSE
!                 Only one processor, NA(2) is the number of leaves
            SIZE_TEMP_MEM = id%NA(2)
         ENDIF
      ELSE
         SIZE_TEMP_MEM = 1
      ENDIF
      IF((id%KEEP(76).EQ.4).OR.(id%KEEP(76).EQ.6))THEN
         SIZE_DEPTH_FIRST=id%KEEP(28)
      ELSE
         SIZE_DEPTH_FIRST=1
      ENDIF
      allocate(TEMP_MEM(SIZE_TEMP_MEM,id%NSLAVES),STAT=allocok)
      IF (allocok .NE.0) THEN
         INFO(1)= -7
         INFO(2)= SIZE_TEMP_MEM*id%NSLAVES
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'TEMP_MEM'
         END IF
         GOTO 80 !! FIXME propagate error
      END IF
      allocate(TEMP_LEAF(SIZE_TEMP_MEM,id%NSLAVES), &
  &           stat=allocok)
      IF (allocok .ne.0) then
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'TEMP_LEAF'
         END IF
         INFO(1)= -7
         INFO(2)= SIZE_TEMP_MEM*id%NSLAVES
         GOTO 80 !! FIXME propagate error
      end if
      allocate(TEMP_SIZE(SIZE_TEMP_MEM,id%NSLAVES), &
  &           stat=allocok)
      IF (allocok .ne.0) then
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'TEMP_SIZE'
         END IF
         INFO(1)= -7
         INFO(2)= SIZE_TEMP_MEM*id%NSLAVES
         GOTO 80
      end if
      allocate(TEMP_ROOT(SIZE_TEMP_MEM,id%NSLAVES), &
  &           stat=allocok)
      IF (allocok .ne.0) then
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'TEMP_ROOT'
         END IF
         INFO(1)= -7
         INFO(2)= SIZE_TEMP_MEM*id%NSLAVES
         GOTO 80
      end if
      allocate(DEPTH_FIRST(SIZE_DEPTH_FIRST),stat=allocok)
      IF (allocok .ne.0) then
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'DEPTH_FIRST'
         END IF
         INFO(1)= -7
         INFO(2)= SIZE_DEPTH_FIRST
         GOTO 80
      end if
      ALLOCATE(DEPTH_FIRST_SEQ(SIZE_DEPTH_FIRST),stat=allocok)
      IF (allocok .ne.0) then
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'DEPTH_FIRST_SEQ'
         END IF
         INFO(1)= -7
         INFO(2)= SIZE_DEPTH_FIRST
         GOTO 80
      end if
      ALLOCATE(SBTR_ID(SIZE_DEPTH_FIRST),stat=allocok)
      IF (allocok .ne.0) then
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'SBTR_ID'
         END IF
         INFO(1)= -7
         INFO(2)= SIZE_DEPTH_FIRST
         GOTO 80
      end if
      IF(id%KEEP(76).EQ.5)THEN
!     We reuse the same variable as before
         SIZE_COST_TRAV=id%KEEP(28)
      ELSE
         SIZE_COST_TRAV=1
      ENDIF
      allocate(COST_TRAV_TMP(SIZE_COST_TRAV),stat=allocok)
      IF (allocok .ne.0) then
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'COST_TRAV_TMP'
         END IF
         INFO(1)= -7
         INFO(2)= SIZE_COST_TRAV
         GOTO 80
      END IF
      IF(id%KEEP(76).EQ.5)THEN
         IF(id%KEEP(70).EQ.0)THEN
            id%KEEP(70)=5
         ENDIF
         IF(id%KEEP(70).EQ.1)THEN
            id%KEEP(70)=6
         ENDIF
      ENDIF
      IF(id%KEEP(76).EQ.4)THEN
         IF(id%KEEP(70).EQ.0)THEN
            id%KEEP(70)=3
         ENDIF
         IF(id%KEEP(70).EQ.1)THEN
            id%KEEP(70)=4
         ENDIF
      ENDIF
      CALL @MUMPS_PREFIX@MUMPS_BUILD_LOAD_MEM_INFO(id%N, id%FRERE_STEPS(1), &
  &           id%STEP(1),id%FILS(1), id%NA(1), id%LNA, &
  &           id%NE_STEPS(1), id%ND_STEPS(1), id%DAD_STEPS(1), &
  &           id%KEEP(28), .TRUE., id%KEEP(28), id%KEEP(70), &
  &           id%KEEP(50), id%INFO(1), id%ICNTL(1),id%KEEP(47), &
  &           id%KEEP(81),id%KEEP(76),id%KEEP(215), &
  &           id%KEEP(234), id%KEEP(55), id%KEEP(199), &
  &           id%PROCNODE_STEPS(1),TEMP_MEM,id%NSLAVES, &
  &           SIZE_TEMP_MEM, PEAK,id%KEEP(90),SIZE_DEPTH_FIRST, &
  &           SIZE_COST_TRAV,DEPTH_FIRST(1),DEPTH_FIRST_SEQ(1), &
  &           COST_TRAV_TMP(1), &
  &           TEMP_LEAF,TEMP_SIZE,TEMP_ROOT,SBTR_ID(1) &
  &              )
   END IF
ENDIF
IF (id%MYID.EQ.MASTER) THEN
   CALL @MUMPS_PREFIX@MUMPS_SORT_PERM(id%N, id%NA(1), id%LNA, &
  &        id%NE_STEPS(1), id%SYM_PERM(1), &
  &        id%FILS(1), id%DAD_STEPS(1), &
  &        id%STEP(1), id%KEEP(28), &
  &        id%KEEP(60), id%KEEP(20), id%KEEP(38), &
  &        id%INFO(1) )
ENDIF
!     Root principal variable
!     for scalapack (KEEP(38)) or special serial root (KEEP(20))
!     might have been updated
!     since root variables might have been permuted
!     and/or expanded (MUMPS_EXPAND_TREE) in case of compressed graph
!     It should thus be redistributed to all procs
IF ( KEEP(494).NE.0 .OR. KEEP(13).NE.0 ) THEN
!       Value of KEEP(20) and KEEP(38) on master is always correct
!       + non-zero status is identical on all procs since 110 first
!       KEEP entries have been broadcasted
  IF (KEEP(38) .NE. 0) THEN
    CALL MPI_BCAST( id%KEEP(38), 1, MPI_INTEGER, MASTER, &
  &      id%COMM, IERR )
  ENDIF
  IF (KEEP(20) .NE. 0) THEN
    CALL MPI_BCAST( id%KEEP(20), 1, MPI_INTEGER, MASTER, &
  &      id%COMM, IERR )
  ENDIF
ENDIF
80 CONTINUE
!     Broadcast errors
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &     id%COMM, id%MYID )
IF ( INFO(1).LT.0 ) GOTO 500
!     ---------------------------------------------------
!     Broadcast information computed on the master to
!     the slaves.
!     The matrix itself with numerical values and
!     integer data for the arrowhead/element description 
!     will be received at the beginning of FACTO.
!     ---------------------------------------------------
CALL MPI_BCAST( id%NA(1), id%LNA, MPI_INTEGER, &
  &     MASTER, id%COMM, IERR )
CALL MPI_BCAST( id%PROCNODE_STEPS(1), id%KEEP(28), MPI_INTEGER, &
  &     MASTER, id%COMM, IERR )
CALL MPI_BCAST( id%DAD_STEPS(1), id%KEEP(28), MPI_INTEGER, &
  &     MASTER, id%COMM, IERR )
CALL MPI_BCAST( id%FRERE_STEPS(1), id%KEEP(28), MPI_INTEGER, &
  &     MASTER, id%COMM, IERR)
CALL MPI_BCAST( id%NE_STEPS(1), id%KEEP(28), MPI_INTEGER, &
  &     MASTER, id%COMM, IERR )
CALL MPI_BCAST( id%ND_STEPS(1), id%KEEP(28), MPI_INTEGER, &
  &       MASTER, id%COMM, IERR )
  CALL MPI_BCAST( id%FILS(1), id%N, MPI_INTEGER, &
  &       MASTER, id%COMM, IERR )
  CALL MPI_BCAST( id%SYM_PERM(1), id%N, MPI_INTEGER, &
  &       MASTER, id%COMM, IERR )
  CALL MPI_BCAST( id%STEP(1), id%N, MPI_INTEGER, &
  &       MASTER, id%COMM, IERR )
  IF(KEEP(494).NE.0) THEN
    CALL MPI_BCAST( id%LRGROUPS(1), id%KEEP(280), MPI_INTEGER, &
  &       MASTER, id%COMM, IERR )
  ENDIF
!     
!     Store size of the stack memory for each
!     of the sequential subtree.
IF((id%KEEP(76).EQ.4).OR.(id%KEEP(76).EQ.6))THEN
   IF(associated(id%DEPTH_FIRST)) THEN
      DEALLOCATE(id%DEPTH_FIRST)
   ENDIF
   allocate(id%DEPTH_FIRST(id%KEEP(28)),stat=allocok)
   IF (allocok .ne.0) then
      INFO(1)= -7
      INFO(2)= id%KEEP(28)
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%DEPTH_FIRST'
      END IF
      GOTO 87
   END IF
   IF(associated(id%DEPTH_FIRST_SEQ)) THEN
      DEALLOCATE(id%DEPTH_FIRST_SEQ)
   ENDIF
   ALLOCATE(id%DEPTH_FIRST_SEQ(id%KEEP(28)),stat=allocok)
   IF (allocok .ne.0) then
      INFO(1)= -7
      INFO(2)= id%KEEP(28)
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%DEPTH_FIRST_SEQ'
      END IF
      GOTO 87
   END IF
   IF(associated(id%SBTR_ID)) THEN
      DEALLOCATE(id%SBTR_ID)
   ENDIF
   ALLOCATE(id%SBTR_ID(id%KEEP(28)),stat=allocok)
   IF (allocok .ne.0) then
      INFO(1)= -7
      INFO(2)= id%KEEP(28)
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%DEPTH_FIRST_SEQ'
      END IF
      GOTO 87
   END IF
   IF(id%MYID.EQ.MASTER)THEN
      id%DEPTH_FIRST(1:id%KEEP(28))=DEPTH_FIRST(1:id%KEEP(28))
      id%DEPTH_FIRST_SEQ(1:id%KEEP(28))= &
  &           DEPTH_FIRST_SEQ(1:id%KEEP(28))
      id%SBTR_ID(1:KEEP(28))=SBTR_ID(1:KEEP(28))
   ENDIF
   CALL MPI_BCAST( id%DEPTH_FIRST(1), id%KEEP(28), MPI_INTEGER, &
  &           MASTER, id%COMM, IERR )
   CALL MPI_BCAST( id%DEPTH_FIRST_SEQ(1), id%KEEP(28), &
  &           MPI_INTEGER,MASTER, id%COMM, IERR )
   CALL MPI_BCAST( id%SBTR_ID(1), id%KEEP(28), &
  &           MPI_INTEGER,MASTER, id%COMM, IERR )
ELSE
   IF(associated(id%DEPTH_FIRST)) THEN
      DEALLOCATE(id%DEPTH_FIRST)
   ENDIF
   allocate(id%DEPTH_FIRST(1),stat=allocok)
   IF (allocok .ne.0) then
      INFO(1)= -7
      INFO(2)= 1
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%DEPTH_FIRST'
      END IF
      GOTO 87
   END IF
   IF(associated(id%DEPTH_FIRST_SEQ)) THEN
      DEALLOCATE(id%DEPTH_FIRST_SEQ)
   ENDIF
   ALLOCATE(id%DEPTH_FIRST_SEQ(1),stat=allocok)
   IF (allocok .ne.0) then
      INFO(1)= -7
      INFO(2)= 1
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%DEPTH_FIRST_SEQ'
      END IF
      GOTO 87
   END IF
   IF(associated(id%SBTR_ID)) THEN
      DEALLOCATE(id%SBTR_ID)
   ENDIF
   ALLOCATE(id%SBTR_ID(1),stat=allocok)
   IF (allocok .ne.0) then
      INFO(1)= -7
      INFO(2)= 1
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%DEPTH_FIRST_SEQ'
      END IF
      GOTO 87
   END IF
   id%SBTR_ID(1)=0
   id%DEPTH_FIRST(1)=0
   id%DEPTH_FIRST_SEQ(1)=0
ENDIF
IF(id%KEEP(76).EQ.5)THEN
   IF(associated(id%COST_TRAV)) THEN
      DEALLOCATE(id%COST_TRAV)
   ENDIF
   allocate(id%COST_TRAV(id%KEEP(28)),stat=allocok)
   IF (allocok .ne.0) then
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%COST_TRAV'
      END IF
      INFO(1)= -7
      INFO(2)= id%KEEP(28)
      GOTO 87
   END IF
   IF(id%MYID.EQ.MASTER)THEN
      id%COST_TRAV(1:id%KEEP(28))= &
  &      dble(COST_TRAV_TMP(1:id%KEEP(28)))
   ENDIF
   CALL MPI_BCAST( id%COST_TRAV(1), id%KEEP(28), &
  &        MPI_DOUBLE_PRECISION,MASTER, id%COMM, IERR )
ELSE
   IF(associated(id%COST_TRAV)) THEN
      DEALLOCATE(id%COST_TRAV)
   ENDIF
   allocate(id%COST_TRAV(1),stat=allocok)
   IF (allocok .ne.0) then
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%COST_TRAV(1)'
      END IF
      INFO(1)= -7
      INFO(2)= 1
      GOTO 87
   END IF
   id%COST_TRAV(1)=0.0d0
ENDIF
IF (id%KEEP(47) .EQ. 4 .OR. &
  &     ((id%KEEP(81) .GT. 0).AND.(id%KEEP(47).GE.2))) THEN
   IF(id%MYID .EQ. MASTER)THEN
      DO K=1,id%NSLAVES
         DO J=1,SIZE_TEMP_MEM
            IF(TEMP_MEM(J,K) < 0.0D0) GOTO 666
         ENDDO
666          CONTINUE
         J=J-1
         IF (id%KEEP(46) == 1) THEN
            IDEST = K - 1
         ELSE
            IDEST = K
         ENDIF
         IF (IDEST .NE. MASTER) THEN
            CALL MPI_SEND(J,1,MPI_INTEGER,IDEST,0, &
  &                 id%COMM,IERR)
            CALL MPI_SEND(TEMP_MEM(1,K),J,MPI_DOUBLE_PRECISION, &
  &                 IDEST, 0, id%COMM,IERR)
            CALL MPI_SEND(TEMP_LEAF(1,K),J,MPI_INTEGER, &
  &                 IDEST, 0, id%COMM,IERR)
            CALL MPI_SEND(TEMP_SIZE(1,K),J,MPI_INTEGER, &
  &                 IDEST, 0, id%COMM,IERR)
            CALL MPI_SEND(TEMP_ROOT(1,K),J,MPI_INTEGER, &
  &                 IDEST, 0, id%COMM,IERR)
         ELSE
            IF(associated(id%MEM_SUBTREE)) THEN
               DEALLOCATE(id%MEM_SUBTREE)
            ENDIF
            allocate(id%MEM_SUBTREE(J),stat=allocok)
            IF (allocok .ne.0) then
               IF ( LPOK ) THEN
                  WRITE(LP, 150) 'id%MEM_SUBTREE'
               END IF
               INFO(1)= -7
               INFO(2)= J
               GOTO 87
            END IF
            id%NBSA_LOCAL = J
            id%MEM_SUBTREE(1:J)=TEMP_MEM(1:J,1)
            IF(associated(id%MY_ROOT_SBTR)) THEN
               DEALLOCATE(id%MY_ROOT_SBTR)
            ENDIF
            allocate(id%MY_ROOT_SBTR(J),stat=allocok)
            IF (allocok .ne.0) then
               IF ( LPOK ) THEN
                  WRITE(LP, 150) 'id%MY_ROOT_SBTR'
               END IF
               INFO(1)= -7
               INFO(2)= J
               GOTO 87
            END IF
            id%MY_ROOT_SBTR(1:J)=TEMP_ROOT(1:J,1)
            IF(associated(id%MY_FIRST_LEAF)) THEN
               DEALLOCATE(id%MY_FIRST_LEAF)
            ENDIF
            allocate(id%MY_FIRST_LEAF(J),stat=allocok)
            IF (allocok .ne.0) then
               IF ( LPOK ) THEN
                  WRITE(LP, 150) 'id%MY_FIRST_LEAF'
               END IF
               INFO(1)= -7
               INFO(2)= J
               GOTO 87
            END IF
            id%MY_FIRST_LEAF(1:J)=TEMP_LEAF(1:J,1)
            IF(associated(id%MY_NB_LEAF)) THEN
               DEALLOCATE(id%MY_NB_LEAF)
            ENDIF
            allocate(id%MY_NB_LEAF(J),stat=allocok)
            IF (allocok .ne.0) then
               IF ( LPOK ) THEN
                  WRITE(LP, 150) 'id%MY_NB_LEAF'
               END IF
               INFO(1)= -7
               INFO(2)= J
               GOTO 87
            END IF
            id%MY_NB_LEAF(1:J)=TEMP_SIZE(1:J,1)
         ENDIF
      ENDDO
   ELSE
      CALL MPI_RECV(id%NBSA_LOCAL,1,MPI_INTEGER, &
  &           MASTER,0,id%COMM,STATUS, IERR)
      IF(associated(id%MEM_SUBTREE)) THEN
         DEALLOCATE(id%MEM_SUBTREE)
      ENDIF
      allocate(id%MEM_SUBTREE(id%NBSA_LOCAL),stat=allocok)
      IF (allocok .ne.0) then
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'id%MEM_SUBTREE'
         END IF
         INFO(1)= -7
         INFO(2)= id%NBSA_LOCAL
         GOTO 87
      END IF
      IF(associated(id%MY_ROOT_SBTR)) THEN
         DEALLOCATE(id%MY_ROOT_SBTR)
      ENDIF
      allocate(id%MY_ROOT_SBTR(id%NBSA_LOCAL),stat=allocok)
      IF (allocok .ne.0) then
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'id%MY_ROOT_SBTR'
         END IF
         INFO(1)= -7
         INFO(2)= id%NBSA_LOCAL
         GOTO 87
      END IF
      IF(associated(id%MY_FIRST_LEAF)) THEN
         DEALLOCATE(id%MY_FIRST_LEAF)
      ENDIF
      allocate(id%MY_FIRST_LEAF(id%NBSA_LOCAL),stat=allocok)
      IF (allocok .ne.0) then
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'MY_FIRST_LEAF'
         END IF
         INFO(1)= -7
         INFO(2)= id%NBSA_LOCAL
         GOTO 87
      END IF
      IF(associated(id%MY_NB_LEAF)) THEN
         DEALLOCATE(id%MY_NB_LEAF)
      ENDIF
      allocate(id%MY_NB_LEAF(id%NBSA_LOCAL),stat=allocok)
      IF (allocok .ne.0) then
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'MY_NB_LEAF'
         END IF
         INFO(1)= -7
         INFO(2)= id%NBSA_LOCAL
         GOTO 87
      END IF
      CALL MPI_RECV(id%MEM_SUBTREE(1),id%NBSA_LOCAL, &
  &           MPI_DOUBLE_PRECISION,MASTER,0, &
  &           id%COMM,STATUS,IERR)
      CALL MPI_RECV(id%MY_FIRST_LEAF(1),id%NBSA_LOCAL, &
  &           MPI_INTEGER,MASTER,0, &
  &           id%COMM,STATUS,IERR)
      CALL MPI_RECV(id%MY_NB_LEAF(1),id%NBSA_LOCAL, &
  &           MPI_INTEGER,MASTER,0, &
  &           id%COMM,STATUS,IERR)
      CALL MPI_RECV(id%MY_ROOT_SBTR(1),id%NBSA_LOCAL, &
  &           MPI_INTEGER,MASTER,0, &
  &           id%COMM,STATUS,IERR)
   ENDIF
ELSE
   id%NBSA_LOCAL = -999999
   IF(associated(id%MEM_SUBTREE)) THEN
      DEALLOCATE(id%MEM_SUBTREE)
   ENDIF
   allocate(id%MEM_SUBTREE(1),stat=allocok)
   IF (allocok .ne.0) then
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%MEM_SUBTREE(1)'
      END IF
      INFO(1)= -7
      INFO(2)= 1
      GOTO 87
   END IF
   IF(associated(id%MY_ROOT_SBTR)) THEN
      DEALLOCATE(id%MY_ROOT_SBTR)
   ENDIF
   allocate(id%MY_ROOT_SBTR(1),stat=allocok)
   IF (allocok .ne.0) then
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%MY_ROOT_SBTR(1)'
      END IF
      INFO(1)= -7
      INFO(2)= 1
      GOTO 87
   END IF
   IF(associated(id%MY_FIRST_LEAF)) THEN
      DEALLOCATE(id%MY_FIRST_LEAF)
   ENDIF
   allocate(id%MY_FIRST_LEAF(1),stat=allocok)
   IF (allocok .ne.0) then
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%MY_FIRST_LEAF(1)'
      END IF
      INFO(1)= -7
      INFO(2)= 1
      GOTO 87
   END IF
   IF(associated(id%MY_NB_LEAF)) THEN
      DEALLOCATE(id%MY_NB_LEAF)
   ENDIF
   allocate(id%MY_NB_LEAF(1),stat=allocok)
   IF (allocok .ne.0) then
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%MY_NB_LEAF(1)'
      END IF
      INFO(1)= -7
      INFO(2)= 1
      GOTO 87
   END IF
ENDIF
IF(id%MYID.EQ.MASTER)THEN
   IF(IS_BUILD_LOAD_MEM_CALLED)THEN
      DEALLOCATE(TEMP_MEM)
      DEALLOCATE(TEMP_SIZE)
      DEALLOCATE(TEMP_ROOT)
      DEALLOCATE(TEMP_LEAF)
      DEALLOCATE(COST_TRAV_TMP)
      DEALLOCATE(DEPTH_FIRST)
      DEALLOCATE(DEPTH_FIRST_SEQ)
      DEALLOCATE(SBTR_ID)
   ENDIF
ENDIF
87 CONTINUE
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &     id%COMM, id%MYID )
IF ( INFO(1).LT.0 ) GOTO 500
!     
NB_NIV2 = KEEP(56)        ! KEEP(1:110) was broadcast earlier
!     NB_NIV2 is now available on all processors.
IF (  NB_NIV2.GT.0  ) THEN
!        Allocate arrays on slaves
   if (id%MYID.ne.MASTER) then
      IF (associated(id%CANDIDATES)) THEN
         DEALLOCATE(id%CANDIDATES)
      ENDIF
      allocate(PAR2_NODES(NB_NIV2), &
  &           id%CANDIDATES(id%NSLAVES+1,NB_NIV2), &
  &           STAT=allocok)
      IF (allocok .ne.0) then
         INFO(1)= -7
         INFO(2)= NB_NIV2*(id%NSLAVES+1)
         IF ( LPOK ) THEN
            WRITE(LP, 150) 'PAR2_NODES/id%CANDIDATES'
         END IF
      end if
   end if
   CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &        id%COMM, id%MYID )
   IF ( INFO(1).LT.0 ) GOTO 500
   CALL MPI_BCAST(PAR2_NODES(1),NB_NIV2, &
  &        MPI_INTEGER, MASTER, id%COMM, IERR )
   IF (KEEP(24) .NE.0 ) THEN
      CALL MPI_BCAST(id%CANDIDATES(1,1), &
  &           (NB_NIV2*(id%NSLAVES+1)), &
  &           MPI_INTEGER, MASTER, id%COMM, IERR )
   ENDIF
ENDIF
IF ( associated(id%ISTEP_TO_INIV2)) THEN
   DEALLOCATE(id%ISTEP_TO_INIV2)
   NULLIFY(id%ISTEP_TO_INIV2)
ENDIF
IF ( associated(id%I_AM_CAND)) THEN
   DEALLOCATE(id%I_AM_CAND)
   NULLIFY(id%I_AM_CAND)
ENDIF
IF (NB_NIV2.EQ.0) THEN
!     allocate dummy arrays
!     ISTEP_TO_INIV2 will never be used 
!     Add a parameter SIZE_ISTEP_TO_INIV2 and make
!     it always available in a keep(71)
   id%KEEP(71) = 1
ELSE
   id%KEEP(71) = id%KEEP(28)
ENDIF
allocate(id%ISTEP_TO_INIV2(id%KEEP(71)), &
  &     id%I_AM_CAND(max(NB_NIV2,1)), &
  &     stat=allocok)
IF (allocok .gt.0) THEN
   IF ( LPOK ) THEN
      WRITE(LP, 150) 'id%ISTEP_TO_INIV2'
      WRITE(LP, 150) 'id%TAB_POS_IN_PERE'
   END IF
   INFO(1)= -7
   IF (NB_NIV2.EQ.0) THEN
      INFO(2)= 2
   ELSE
      INFO(2)= id%KEEP(28)+NB_NIV2*(id%NSLAVES+2)
   END IF
   GOTO 321
ENDIF
IF ( NB_NIV2 .GT.0 ) THEN
!   If BLR grouping was performed then PAR2_NODES(INIV2) 
!   might then point to a non principal variable
!   for which STEP might be negative
!
   id%ISTEP_TO_INIV2 = -9999
   DO INIV2 = 1, NB_NIV2
      INN = PAR2_NODES(INIV2)
      id%ISTEP_TO_INIV2(abs(id%STEP(INN))) = INIV2
   END DO
   CALL @MUMPS_PREFIX@MUMPS_BUILD_I_AM_CAND( id%NSLAVES, KEEP(79), &
  &        NB_NIV2, id%MYID_NODES, &
  &        id%CANDIDATES(1,1), id%I_AM_CAND(1) )
ENDIF
IF ( I_AM_SLAVE ) THEN
   IF (associated(id%FUTURE_NIV2)) THEN
      DEALLOCATE(id%FUTURE_NIV2)
      NULLIFY(id%FUTURE_NIV2)
   ENDIF
   allocate(id%FUTURE_NIV2(id%NSLAVES), stat=allocok)
   IF (allocok .gt.0) THEN
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'FUTURE_NIV2'
      END IF
      INFO(1)= -7
      INFO(2)= id%NSLAVES
      GOTO 321
   ENDIF
   id%FUTURE_NIV2=0
   DO INIV2 = 1, NB_NIV2
      IDEST = MUMPS_PROCNODE( &
  &           id%PROCNODE_STEPS(abs(id%STEP(PAR2_NODES(INIV2)))), &
  &           id%KEEP(199))
      id%FUTURE_NIV2(IDEST+1)=id%FUTURE_NIV2(IDEST+1)+1
   ENDDO
!     Allocate id%TAB_POS_IN_PERE, 
!     TAB_POS_IN_PERE is an array of size (id%NSLAVES+2,NB_NIV2)
!     where NB_NIV2 is the number of type 2 nodes in the tree.
   IF ( associated(id%TAB_POS_IN_PERE)) THEN
      DEALLOCATE(id%TAB_POS_IN_PERE)
      NULLIFY(id%TAB_POS_IN_PERE)
   ENDIF
   allocate(id%TAB_POS_IN_PERE(id%NSLAVES+2,max(NB_NIV2,1)), &
  &        stat=allocok)
   IF (allocok .gt.0) THEN
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%ISTEP_TO_INIV2'
         WRITE(LP, 150) 'id%TAB_POS_IN_PERE'
      END IF
      INFO(1)= -7
      IF (NB_NIV2.EQ.0) THEN
         INFO(2)= 2
      ELSE
         INFO(2)= id%KEEP(28)+NB_NIV2*(id%NSLAVES+2)
      END IF
      GOTO 321
   ENDIF
END IF
!     deallocate PAR2_NODES  that was computed
!     on master and broadcasted on all slaves
IF (NB_NIV2.GT.0) DEALLOCATE (PAR2_NODES)
321 CONTINUE
!     ----------------
!     Check for errors
!     ----------------
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &     id%COMM, id%MYID )
IF ( INFO(1).LT.0 ) GOTO 500
!
IF ( KEEP(38) .NE. 0 ) THEN
!     -------------------------
!     Initialize root structure
!     -------------------------
   CALL @MUMPS_PREFIX@MUMPS_INIT_ROOT_ANA( id%MYID, &
  &        id%NSLAVES, id%N, idintr%root, &
  &        id%COMM_NODES, KEEP( 38 ), id%FILS(1), &
  &        id%KEEP(50), id%KEEP(46), &
  &        id%KEEP(51) &
  &        , id%KEEP(60), id%NPROW, id%NPCOL, id%MBLOCK, id%NBLOCK &
  &        )
ELSE
   idintr%root%yes = .FALSE.
END IF
IF ( KEEP(38) .NE. 0 .and. I_AM_SLAVE ) THEN
!     -----------------------------------------------
!     Check if at least one processor belongs to the
!     root. In the case where all of them have MYROW
!     equal to -1, this could be a problem due to the
!     BLACS. (mpxlf90_r and IBM BLACS).
!     -----------------------------------------------
   CALL MPI_ALLREDUCE(idintr%root%MYROW, MYROW_CHECK, 1, &
  &        MPI_INTEGER, MPI_MAX, id%COMM_NODES, IERR)
   IF ( MYROW_CHECK .eq. -1) THEN
      INFO(1) = -25
      INFO(2) = 0
   END IF
   IF ( idintr%root%MYROW .LT. -1 .OR. &
  &        idintr%root%MYCOL .LT. -1 ) THEN
      INFO(1) = -25
      INFO(2) = 0
   END IF
   IF ( LPOK .AND. INFO(1) == -25 ) THEN
      WRITE(LP, '(A)') &
  &           'Problem with your version of the BLACS.'
      WRITE(LP, '(A)') 'Try using a BLACS version from netlib.'
   ENDIF
END IF
!     ----------------
!     Check for errors
!     ----------------
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &     id%COMM, id%MYID )
IF ( INFO(1).LT.0 ) GOTO 500
!     
!     
!
 CALL @MUMPS_PREFIX@MUMPS_ANA_ARROWHEADS_WRAPPER ( id, &
  &                   GATHER_MATRIX_ALLOCATED )
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &             id%COMM, id%MYID )
IF ( INFO(1).LT.0 ) GOTO 500
CALL  @MUMPS_PREFIX@MUMPS_ANA_COMPUTE_ESTIMATES (id,idintr)
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &             id%COMM, id%MYID )
IF ( INFO(1).LT.0 ) GOTO 500
!     -------------------------
!     Define a specific mapping
!     for the user
!     -------------------------
IF ( id%MYID. eq. MASTER .AND. KEEP(54) .eq. 1 ) THEN
   IF (associated( id%MAPPING)) THEN
      DEALLOCATE( id%MAPPING)
   ENDIF
   allocate( id%MAPPING(id%KEEP8(28)), stat=allocok)
   IF ( allocok .GT. 0 ) THEN
      INFO(1) = -7
      CALL MUMPS_SETI8TOI4(id%KEEP8(28), INFO(2))
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'id%MAPPING'
      END IF
      GOTO 92
   END IF
   allocate(IWtemp( id%N ), stat=allocok)
   IF ( allocok .GT. 0 ) THEN
      INFO(1)=-7
      INFO(2)=id%N
      IF ( LPOK ) THEN
         WRITE(LP, 150) 'IWtemp(N)'
      END IF
      GOTO 92
   END IF
   IF ( id%KEEP8(28) .EQ. 0_8 ) THEN
     IRN_PTR => IDUMMY_ARRAY
     JCN_PTR => IDUMMY_ARRAY
   ELSE
     IRN_PTR => id%IRN
     JCN_PTR => id%JCN
   ENDIF
   CALL @MUMPS_PREFIX@MUMPS_BUILD_MAPPING( &
  &        id%N, id%MAPPING(1), id%KEEP8(28), &
  &        IRN_PTR(1),JCN_PTR(1), id%PROCNODE_STEPS(1), &
  &        id%STEP(1), &
  &        id%NSLAVES, id%SYM_PERM(1), &
  &        id%FILS(1), IWtemp, id%KEEP(1),id%KEEP8(1), &
  &        idintr%root%MBLOCK, idintr%root%NBLOCK, &
  &        idintr%root%NPROW, idintr%root%NPCOL )
   DEALLOCATE( IWtemp )
92    CONTINUE
END IF
CALL MUMPS_PROPINFO( ICNTL(1), INFO(1), &
  &     id%COMM, id%MYID )
IF ( INFO(1) .LT. 0 ) GOTO 500
! 
500 CONTINUE
!     Deallocate allocated working space
IF (allocated(FILS_TMP)) DEALLOCATE(FILS_TMP)
IF (allocated(STEP_TMP)) DEALLOCATE(STEP_TMP)
IF (allocated(LRGROUPS_TMP)) DEALLOCATE(LRGROUPS_TMP)
IF (allocated(IKEEPALLOC)) DEALLOCATE(IKEEPALLOC)
IF (allocated(WORK2ALLOC)) DEALLOCATE(WORK2ALLOC)
IF (KEEP(244).NE.1) THEN
  IF (allocated(PARAORD_to_idCOMM)) &
  &    DEALLOCATE(PARAORD_to_idCOMM)
  IF (COMM_PARAORD_ALLOCATED) THEN
     IF (COMM_PARAORD.NE.MPI_COMM_NULL) THEN
      CALL MPI_COMM_FREE( COMM_PARAORD, IERR )
      COMM_PARAORD_ALLOCATED = .FALSE.
     ENDIF
  ENDIF
  IF (COMM_PARASYMB_ALLOCATED) THEN
     IF (COMM_PARASYMB.NE.MPI_COMM_NULL) THEN
       CALL MPI_COMM_FREE( COMM_PARASYMB, IERR )
       COMM_PARASYMB_ALLOCATED = .FALSE.
     ENDIF
  ENDIF
ENDIF
IF (allocated(PROCNODE)) DEALLOCATE(PROCNODE)
IF (allocated(XNODEL)) DEALLOCATE(XNODEL)
IF (allocated(NODEL)) DEALLOCATE(NODEL)
IF (allocated(SIZEOFBLOCKS)) DEALLOCATE(SIZEOFBLOCKS)
IF (allocated(DOF2BLOCK)) DEALLOCATE(DOF2BLOCK)
CALL MUMPS_AB_FREE_LMAT(LMAT_BLOCK,KEEP(147))
CALL MUMPS_AB_FREE_LMAT(LUMAT,KEEP(147))
CALL MUMPS_AB_FREE_LMAT(LUMAT_REMAP,KEEP(147))
CALL MUMPS_AB_FREE_GCOMP(GCOMP, MEMCNT)
CALL MUMPS_AB_FREE_GCOMP(GCOMP_DIST, MEMCNT)
!     Standard deallocations (error or not)
IF (associated(NFSIZPTR)) DEALLOCATE(NFSIZPTR)
IF (associated(FREREPTR)) DEALLOCATE(FREREPTR)
nullify(FREREPTR, NFSIZPTR)
IF (associated(BLKPTR_PTRLOC).AND.BLKPTR_ALLOCATED) THEN
  DEALLOCATE(BLKPTR_PTRLOC)
  nullify(BLKPTR_PTRLOC)
ENDIF
IF (associated(BLKVAR_PTRLOC).AND.BLKVAR_ALLOCATED) THEN
  DEALLOCATE(BLKVAR_PTRLOC)
  nullify(BLKVAR_PTRLOC)
ENDIF
KEEP8(26)=max(1_8,KEEP8(26))
KEEP8(27)=max(1_8,KEEP8(27))
RETURN
110 FORMAT(/' ****** ANALYSIS STEP ********'/)
145 FORMAT(' ELAPSED TIME SPENT IN BLR CLUSTERING    =',F12.4)
150 FORMAT( &
  & /' ** FAILURE DURING @MUMPS_PREFIX@MUMPS_ANA_DRIVER, DYNAMIC ALLOCATION OF', &
  &     A30)
END SUBROUTINE @MUMPS_PREFIX@MUMPS_ANA_DRIVER
SUBROUTINE @MUMPS_PREFIX@MUMPS_ANA_CHECK_KEEP(id, I_AM_SLAVE)
!$    USE OMP_LIB, ONLY : omp_get_max_threads
!
!  Purpose
!  =======
!  This subroutine decodes the control parameters,
!  stores them in the KEEP array, and performs a
!  consistency check on the KEEP array.
USE @MUMPS_PREFIX@MUMPS_STRUC_DEF
IMPLICIT NONE
TYPE(@MUMPS_PREFIX@MUMPS_STRUC)  :: id
LOGICAL :: I_AM_SLAVE
!     internal variables
INTEGER   :: LP, MP, MPG, I
INTEGER   :: MASTER
LOGICAL   :: PROK, PROKG, LPOK
PARAMETER( MASTER = 0 )
!
LP  = id%ICNTL( 1 )
MP  = id%ICNTL( 2 )
MPG = id%ICNTL( 3 )
!     LP     : errors
!     MP     : INFO
LPOK  = ((LP.GT.0).AND.(id%ICNTL(4).GE.1))
PROK  = (( MP  .GT. 0 ).AND.(id%ICNTL(4).GE.2))
PROKG = ( MPG .GT. 0 .and. id%MYID .eq. MASTER )
PROKG = (PROKG.AND.(id%ICNTL(4).GE.2))
!     Re-intialize few KEEPs entries corresponding
!     to stat that are incremented such
!     the number of split nodes:
id%KEEP(61)=0
IF (id%MYID.eq.MASTER) THEN
  id%KEEP(38) = 0
  id%KEEP(20) = 0
  CALL @MUMPS_PREFIX@MUMPS_ANA_CHECK_ICNTL48 ( id )
  id%KEEP(256) = id%ICNTL(7) ! copy ordering option
  id%KEEP(252) = id%ICNTL(32)
  IF (id%KEEP(252) < 0 .OR. id%KEEP(252) > 1 ) THEN
    id%KEEP(252) = 0
  ENDIF
!       Which factors to store
  id%KEEP(251) = id%ICNTL(31)
  IF (id%KEEP(251) < 0 .OR. id%KEEP(251) > 2 ) THEN
    id%KEEP(251)=0
  ENDIF
!       For unsymmetric matrices, if forward solve 
!       performed during facto,
!       no reason to store L factors at all. Reset
!       KEEP(251) accordingly... except if the user
!       tells that no solve is needed.
  IF (id%KEEP(50) .EQ. 0 .AND. id%KEEP(252).EQ.1) THEN
    IF (id%KEEP(251) .NE. 1) id%KEEP(251) = 2
  ENDIF
!       Symmetric case, even if no backward needed,
!       store all factors
  IF (id%KEEP(50) .NE.0 .AND. id%KEEP(251) .EQ. 2) THEN
    id%KEEP(251) = 0
  ENDIF
!       Case of solve not needed:
  IF (id%KEEP(251) .EQ. 1) THEN
    id%KEEP(201) = -1
!         In that case, id%ICNTL(22) will
!         be ignored in future phases
  ELSE
!         Reset id%KEEP(201) -- typically for the case
!         of a previous analysis with KEEP(201)=-1
    id%KEEP(201) = 0
  ENDIF
  IF (id%KEEP(252).EQ.1) THEN
    id%KEEP(253) = id%NRHS
    IF (id%KEEP(253) .LE. 0) THEN
      id%INFO(1)=-42
      id%INFO(2)=id%NRHS
      RETURN
    ENDIF
  ELSE
    id%KEEP(253) = 0
  ENDIF
ENDIF
IF ( (id%KEEP(24).NE.0) .AND. &
  &     id%NSLAVES.eq.1 ) THEN
   id%KEEP(24) = 0
END IF
IF ( (id%KEEP(24).EQ.0) .AND. &
  &     id%NSLAVES.GT.1 ) THEN
   id%KEEP(24) = 8
ENDIF
IF ( (id%KEEP(24).NE.0)  .AND. (id%KEEP(24).NE.1)  .AND. &
  &     (id%KEEP(24).NE.8)  .AND. (id%KEEP(24).NE.10) .AND. &
  &     (id%KEEP(24).NE.12) .AND. (id%KEEP(24).NE.14) .AND. &
  &     (id%KEEP(24).NE.16) .AND. (id%KEEP(24).NE.18)) THEN
   id%KEEP(24) = 8
END IF
!****************************************************
!     
!     The master is doing most of the work
!     
!     NOTE:  Treatment of the errors on the master=
!     Go to the next SPMD part of the code in which
!     the first statement must be a call to PROPINFO
!     
!****************************************************
!     =========================================
!     Check (raise error or modify) some input
!     parameters or KEEP values on the master.
!     =========================================
id%KEEP8(21) = int(id%KEEP(85),8)
IF ( id%MYID .EQ. MASTER ) THEN
!        ----------------------------
!        Save id%ICNTL(18) (distributed
!        matrix on entry) in id%KEEP(54)
!        ----------------------------
   id%KEEP(54) = id%ICNTL(18)
   IF ( id%KEEP(54) .LT. 0 .or. id%KEEP(54).GT.3 ) THEN
      IF ( PROKG ) THEN
         WRITE(MPG, *) ' Out-of-range value for id%ICNTL(18).'
         WRITE(MPG, *) ' Used 0 ie matrix not distributed'
      END IF
      id%KEEP(54) = 0
   END IF
   IF ( id%KEEP(54) .EQ. 1 ) THEN
      IF ( PROKG ) THEN
         WRITE(MPG, *) ' Option id%ICNTL(18)=1 is obsolete.'
         WRITE(MPG, *) ' We recommend not to use it.'
         WRITE(MPG, *) ' It will disappear in a future release'
      END IF
   END IF
!     -----------------------------------------
!     Save id%ICNTL(5) (matrix format) in id%KEEP(55)
!     -----------------------------------------
   id%KEEP(55) = id%ICNTL(5)
   IF ( id%KEEP(55) .LT. 0 .OR. id%KEEP(55) .GT. 1 ) THEN
      IF ( PROKG ) THEN
         WRITE(MPG, *) ' Out-of-range value for id%ICNTL(5).'
         WRITE(MPG, *) ' Used 0 ie matrix is assembled'
      END IF
      id%KEEP(55) = 0
   END IF
   id%KEEP(60) = id%ICNTL(19)
   IF ( id%KEEP( 60 ) .LE. 0 ) id%KEEP( 60 ) = 0
   IF ( id%KEEP( 60 ) .GT. 3 ) id%KEEP( 60 ) = 0
   IF (id%KEEP(60) .NE. 0 .AND. id%SIZE_SCHUR == 0 ) THEN
      IF (PROKG) THEN
        WRITE(MPG,'(A)') &
  &        ' ** Schur option ignored because SIZE_SCHUR=0'
      ENDIF
      id%KEEP(60)=0
   END IF
!        ---------------------------------------
!        Save SIZE_SCHUR in a KEEP, for possible
!        check at factorization and solve phases
!        ---------------------------------------
   IF ( id%KEEP(60) .NE.0 ) THEN
      id%KEEP(116) = id%SIZE_SCHUR
      IF (id%SIZE_SCHUR .LT. 0 .OR. id%SIZE_SCHUR .GE. id%N) THEN
        id%INFO(1)=-49
        id%INFO(2)=id%SIZE_SCHUR
        RETURN
      ENDIF
!           List of Schur variables provided by user.
      IF ( .NOT. associated( id%LISTVAR_SCHUR ) ) THEN
         id%INFO(1) = -22
         id%INFO(2) = 8
         RETURN
      ELSE IF (size(id%LISTVAR_SCHUR)<id%SIZE_SCHUR) THEN
         id%INFO(1) = -22
         id%INFO(2) = 8
         RETURN
      END IF
   ENDIF
   IF (id%KEEP(60) .EQ. 3 .AND. id%KEEP(50).NE.0) THEN
      IF (id%MBLOCK > 0 .AND. id%NBLOCK > 0 .AND. &
  &           id%NPROW > 0 .AND. id%NPCOL > 0 ) THEN
         IF (id%NPROW *id%NPCOL .LE. id%NSLAVES) THEN
!     We will eventually have to "symmetrize the
!     Schur complement. For that NBLOCK and MBLOCK
!     must be equal.
            IF (id%MBLOCK .NE. id%NBLOCK ) THEN
               id%INFO(1)=-31
               id%INFO(2)=id%MBLOCK - id%NBLOCK
               RETURN
            ENDIF
         ENDIF
      ENDIF
   ENDIF
!     Check the ordering strategy and compatibility with
!     other control parameters
   id%KEEP(244) = id%ICNTL(28)
   IF ((id%KEEP(244) .LT. 0) .OR. (id%KEEP(244) .GT. 2)) THEN
     id%KEEP(244) = 0
   ENDIF
   IF(id%KEEP(244) .EQ. 0) THEN ! Automatic
!           One could check for availability of parallel ordering
!           tools, or for possible options incompatible with //
!           analysis to decide (e.g. avoid returning an error if
!           // analysis not compatible with some option but user
!           lets MUMPS decide to choose sequential or paralllel
!           analysis)
!           Current strategy for automatic is sequential analysis
      id%KEEP(244) = 1
   ENDIF
#if ! defined (ptscotch) && ! defined(parmetis) && ! defined(parmetis3) 
   IF (id%KEEP(244) .EQ. 2) THEN
      id%INFO(1)  = -38
      IF ( LPOK ) THEN
         WRITE(LP,'("ParMETIS and PT-SCOTCH not available.")')
      END IF
      RETURN
   END IF
#endif
   id%KEEP(245) = id%ICNTL(29)
   IF ((id%KEEP(245) .LT. 0) .OR. (id%KEEP(245) .GT. 2)) THEN
     id%KEEP(245) = 0
   END IF
   IF (id%KEEP(244) .EQ. 2) THEN
      IF ( id%KEEP(245).EQ.0 ) THEN
#if defined(parmetis) || defined(parmetis3)
        id%KEEP(245) = 2
#elif defined(ptscotch)         
        id%KEEP(245) = 1
#endif
      ENDIF
   ENDIF
!
#if ! defined(parmetis) && ! defined(parmetis3)        
   IF ((id%KEEP(244) .EQ. 2) .AND. (id%KEEP(245) .EQ. 2)) THEN
      id%INFO(1)  = -38
      IF ( LPOK ) THEN
         WRITE(LP,'("ParMETIS not available.")')
      END IF
      RETURN
   END IF
#endif
#if ! defined(ptscotch)         
   IF ((id%KEEP(244) .EQ. 2) .AND. (id%KEEP(245) .EQ. 1)) THEN
      id%INFO(1)  = -38
      IF ( LPOK ) THEN
         WRITE(LP,'("PT-SCOTCH not available.")')
      END IF
      RETURN
   END IF
#endif
   IF (id%KEEP(244) .EQ. 2) THEN
      IF(id%KEEP(55) .NE. 0) THEN
         id%INFO(1)  = -39
         IF (LPOK) THEN
         WRITE(LP, &
  &              '("Incompatible values for ICNTL(5), ICNTL(28)")')
         WRITE(LP, &
  &              '("Parallel analysis is not possible if the")')
         WRITE(LP, &
  &              '("matrix is not assembled")')
         ENDIF
         RETURN
      ELSE IF(id%KEEP(60) .NE. 0) THEN
         id%INFO(1)  = -39
         IF (LPOK) THEN
         WRITE(LP, &
  &              '("Incompatible values for ICNTL(19), ICNTL(28)")')
         WRITE(LP, &
  &              '("Parallel analysis is not possible if SCHUR")')
         WRITE(LP, &
  &              '("complement must be returned")')
         ENDIF
         RETURN
      END IF
!     In the case where there are too few processes to do
!     the parallel analysis we simply revert to sequential version
      IF(id%NSLAVES .LT. 2) THEN
         id%KEEP(244) = 1
         IF(PROKG) WRITE(MPG, &
  &              '("Too few processes. &
  & Reverting to sequential analysis")',advance='no')
         IF(id%KEEP(245) .EQ. 1) THEN
!                 Scotch necessarily available because pt-scotch
!                 is, otherwise an error would have occurred
            IF(PROKG) WRITE(MPG, '(" with SCOTCH.")')
            id%KEEP(256) = 3
         ELSE IF(id%KEEP(245) .EQ. 2) THEN
!                 Metis necessarily available because parmetis
!                 is, otherwise an error would have occurred
            IF(PROKG) WRITE(MPG, '(" with Metis.")')
            id%KEEP(256) = 5
         ELSE
            IF(PROKG) WRITE(MPG, '(".")')
            id%KEEP(256) = 7
         END IF
      END IF
!     In the case where there the input matrix is too small to do
!     the parallel analysis we simply revert to sequential version
      IF(id%N .LE. 50) THEN
         id%KEEP(244) = 1
         IF(PROKG) WRITE(MPG, &
  &            '("Input matrix is too small for the parallel &
  & analysis. Reverting to sequential analysis")',advance='no')
         IF(id%KEEP(245) .EQ. 1) THEN
            IF(PROKG) WRITE(MPG, '(" with SCOTCH.")')
            id%KEEP(256) = 3
         ELSE IF(id%KEEP(245) .EQ. 2) THEN
            IF(PROKG) WRITE(MPG, '(" with Metis.")')
            id%KEEP(256) = 5
         ELSE
            IF(PROKG) WRITE(MPG, '(".")')
            id%KEEP(256) = 7
         END IF
      END IF
   END IF
   id%INFOG(32) = id%KEEP(244)
   IF ( (id%KEEP(244) .EQ. 1) .AND. &
  &        (id%KEEP(256) .EQ. 1) ) THEN
!     ordering given, PERM_IN must be of size N
      IF ( .NOT. associated( id%PERM_IN ) ) THEN
         id%INFO(1) = -22
         id%INFO(2) = 3
         RETURN
      ELSE IF ( size( id%PERM_IN ) < id%N ) THEN
         id%INFO(1) = -22
         id%INFO(2) = 3
         RETURN
      END IF
   ENDIF
!     Check KEEP(9-10) for level 2
   IF (id%KEEP(9) .LE. 1 ) id%KEEP(9) = 500
   IF ( id%KEEP8(21) .GT. 0_8 ) THEN
      IF ((id%KEEP8(21).LE.1_8) .OR. &
  &          (id%KEEP8(21).GT.int(id%KEEP(9),8))) &
  &         id%KEEP8(21) = int(min(id%KEEP(9),100),8)
   ENDIF
!     
   IF (id%KEEP(48). EQ. 1 ) id%KEEP(48) = -12345
!     
   IF ( (id%KEEP(48).LT.0) .OR. (id%KEEP(48).GT.5) ) THEN
      id%KEEP(48)=5
   ENDIF
!     Schur 
!     Given ordering must be compatible with Schur variables.
   IF ( (id%KEEP(60) .NE. 0) .AND. (id%KEEP(256) .EQ. 1) ) THEN
      DO I = 1, id%SIZE_SCHUR
         IF (id%PERM_IN(id%LISTVAR_SCHUR(I)) &
  &              .EQ. id%N-id%SIZE_SCHUR+I) &
  &              CYCLE
!              -------------------------------
!              Problem with PERM_IN: -22/3
!              Above constrained explained in
!              doc of PERM_IN in user guide.
!              -------------------------------
         id%INFO(1) = -4
         id%INFO(2) = id%LISTVAR_SCHUR(I)
         RETURN
         IF (PROKG) THEN
            WRITE(MPG,'(A)') &
  & ' ** Ignoring user-ordering, because incompatible with Schur.'
            WRITE(MPG,'(A)') ' ** id%ICNTL(7) treated as 0.'
         END IF
         EXIT
      ENDDO
   END IF
!     
!     Note that schur is not compatible with
!     
!     1/Max-trans DONE
!     2/Null space
!     3/Ordering given DONE
!     4/Scaling
!     5/Iterative Refinement
!     6/Error analysis
!     7/Parallel Analysis
!     
!     Graph modification prior to ordering (id%ICNTL(12) option)
!     id%KEEP (95) will hold the eventually modified value of id%ICNTL(12)
!     
   id%KEEP(95) = id%ICNTL(12)
!        reset to usual ordering (KEEP(95)=1)
!          - when matrix is not general symmetric 
!          - for out-of-range values
   IF (id%KEEP(50).NE.2) id%KEEP(95) = 1
   IF ((id%KEEP(95).GT.3).OR.(id%KEEP(95).LT.0)) id%KEEP(95) = 1
!     MAX-TRANS
!     
!     id%KEEP (23) will hold the eventually modified value of id%ICNTL(6)
!     (maximum transversal if >= 1)
!     
   id%KEEP(23) = id%ICNTL(6)
!     
!     
!     --------------------------------------------
!     Avoid max-trans unsymmetric permutation in case of
!     matrix is symmetric with SYM=1 or 
!     ordering is given,
!     or matrix is in element form, or Schur is asked
!     or initial matrix is distributed
!     --------------------------------------------
   IF (id%KEEP(23).LT.0.OR.id%KEEP(23).GT.7) id%KEEP(23) = 0
!        still forbid max trans for SYM=1 case
   IF ( id%KEEP(50) .EQ. 1 ) THEN
      IF (id%KEEP(23) .NE. 0) THEN
         IF (PROKG) THEN
            WRITE(MPG,'(A)') &
  & ' ** Max-trans not needed with SYM=1 factorization'
         END IF
         id%KEEP(23) = 0
      ENDIF
      IF (id%KEEP(95) .GT. 1) THEN
         IF (PROKG) THEN
            WRITE(MPG,'(A)') &
  & ' ** ICNTL(12) ignored: not needed with SYM=1 factorization'
         END IF
      ENDIF
      id%KEEP(95) = 1
   END IF
!     
   IF  (id%KEEP(60) .GT. 0) THEN
      IF (id%KEEP(23) .NE. 0) THEN
         IF (PROKG) THEN
            WRITE(MPG,'(A)') &
  &                 ' ** Max-trans not allowed because of Schur'
         END IF
         id%KEEP(23) = 0
      ENDIF
      IF (id%KEEP(52).EQ.-2) THEN
         IF (PROKG) THEN
            WRITE(MPG,'(A)') &
  & ' ** Scaling during analysis not allowed because of Schur'
         ENDIF
         id%KEEP(52) = 0
      ENDIF
!     also forbid compressed/constrained ordering...
      IF (id%KEEP(95) .GT. 1) THEN
         IF (PROKG) THEN
            WRITE(MPG,'(A)') &
  & ' ** ICNTL(12) option not allowed because of Schur'
         END IF
      ENDIF
      id%KEEP(95) = 1
   END IF
   IF ( (id%KEEP(23) .NE. 0) .AND. (id%KEEP(256).EQ.1)) THEN
      id%KEEP(23) = 0
      IF (PROKG) THEN
         WRITE(MPG,'(A,A)') &
  &          ' ** Maximum transversal (ICNTL(6)) not allowed ', &
  &         'because ordering is given'
      END IF
   END IF
   IF ( id%KEEP(256) .EQ. 1 ) THEN
      IF (id%KEEP(95) > 1 .AND. PROKG) THEN
         WRITE(MPG,'(A)') &
  &      ' ** ICNTL(12) option incompatible with given ordering'
      END IF
      id%KEEP(95) = 1
   END IF
   IF (id%KEEP(54) .NE. 0) THEN
      IF( id%KEEP(23) .NE. 0 ) THEN
         IF (PROKG) THEN
            WRITE(MPG,'(A,A)') &
  &            ' ** Maximum transversal (ICNTL(6)) not allowed ', &
  &            'because matrix is distributed'
         END IF
         id%KEEP(23) = 0
      ENDIF
      IF (id%KEEP(52).EQ.-2) THEN
         IF (PROKG) THEN
            WRITE(MPG,'(A,A)') &
  &            ' ** Scaling (ICNTL(8)) during analysis not ', &
  &            'allowed because matrix is distributed)'
         ENDIF
      ENDIF
      id%KEEP(52) = 0
      IF (id%KEEP(95) .GT. 1 .AND. MPG.GT.0) THEN
         WRITE(MPG,'(A,A)') &
  &         ' ** ICNTL(12) option not allowed because matrix is ', &
  &         'distributed'
      ENDIF
      id%KEEP(95) = 1
   END IF
   IF ( id%KEEP(55) .NE. 0 ) THEN
      IF( id%KEEP(23) .NE. 0 ) THEN
         IF (PROKG) THEN
            WRITE(MPG,'(A,A)') &
  &            ' ** Maximum transversal (ICNTL(6)) not allowed ', &
  &            'for matrices in elemental format'
         END IF
         id%KEEP(23) = 0
      ENDIF
      IF (PROKG .AND. id%KEEP(52).EQ.-2) THEN
         WRITE(MPG,'(A)') &
  &            ' ** Scaling (ICNTL(8)) not allowed ', &
  &            'for matrices in elemental format'
      ENDIF
      id%KEEP(52) = 0
      id%KEEP(95) = 1
   ENDIF
!     In the case where parallel analysis is done, column permutation
!     is not allowed
   IF(id%KEEP(244) .EQ. 2) THEN
      IF(id%KEEP(23) .EQ. 7) THEN
!     Automatic hoice: set it to 0
         id%KEEP(23) = 0
      ELSE IF (id%KEEP(23) .GT. 0) THEN
         id%INFO(1)  = -39
         id%KEEP(23) = 0
         IF (LPOK) THEN
         WRITE(LP, &
  &              '("Incompatible values for ICNTL(6), ICNTL(28)")')
         WRITE(LP, &
  &              '("Maximum transversal not allowed &
  &                 in parallel analysis")')
         ENDIF
         RETURN
      END IF
   END IF
!     --------------------------------------------
!     Avoid distributed entry for element matrix.
!     --------------------------------------------
   IF ( id%KEEP(54) .NE. 0 .AND. id%KEEP(55) .NE. 0 ) THEN
      id%KEEP(54) = 0
      IF (PROKG) THEN
         WRITE(MPG,'(A)') &
  & ' ** Distributed entry not available for element matrix'
      END IF
   ENDIF
!     ----------------------------------
!     Choice of symbolic analysis option
!     ----------------------------------
   IF (id%ICNTL(58).NE.1 .and. id%ICNTL(58).NE.2 &
  &    .and. id%ICNTL(58).NE.3 .and.  id%ICNTL(58).NE.4 ) THEN
!           out of range values leads to default
      id%KEEP(106)=2
   ELSE
      id%KEEP(106)=id%ICNTL(58)
!           Options 3 and 4 not available, reset to default
      IF (id%KEEP(106).EQ.4) id%KEEP(106)=2
      IF (id%KEEP(106).EQ.3) id%KEEP(106)=2
   ENDIF
!     modify input parameters to avoid incompatible
!     input data between ordering, scaling and maxtrans
!     note that if id%ICNTL(12)/id%KEEP(95) = 0 then
!     the automatic choice will be done in ANA_O
   IF(id%KEEP(50) .EQ. 2) THEN
!     LDLT case
      IF( .NOT. associated(id%A) ) THEN
!     constraint ordering can be computed only if values are
!     given to analysis
         IF(id%KEEP(95) .EQ. 3) THEN
            id%KEEP(95) = 2
         ENDIF
      ENDIF
      IF(id%KEEP(95) .EQ. 3 .AND. id%KEEP(256) .NE. 2) THEN
!     if constraint and ordering is not AMF then use compress
         IF (PROK) WRITE(MP,*) &
  &              'WARNING: @MUMPS_PREFIX@MUMPS_ANA_O constrained ordering not ', &
  &              'available with selected ordering'
         id%KEEP(95) = 2
      ENDIF
      IF(id%KEEP(95) .EQ. 3) THEN
!     if constraint ordering required then we need to compute scaling
!     and max trans
!     NOTE that if we enter this condition then
!     id%A is associated because of the test above:
!     (IF( .NOT. associated(id%A) ) THEN)
         id%KEEP(23) = 5
         id%KEEP(52) = -2
      ELSE IF(id%KEEP(95) .EQ. 2 .AND. &
  &              (id%KEEP(23) .EQ. 0 .OR. id%KEEP(23) .EQ. 7) ) THEN
!     compressed ordering requires max trans but not necessary scaling
         IF( associated(id%A) ) THEN
            id%KEEP(23) = 5
         ELSE
!     we can do compressed ordering without
!     information on the numerical values:
!     a maximum transversal already provides
!     information on the location of off-diagonal
!     nonzeros which can be candidates for 2x2
!     pivots
            id%KEEP(23) = 1
         ENDIF
      ELSE IF(id%KEEP(95) .EQ. 1) THEN
         id%KEEP(23) = 0
      ELSE IF(id%KEEP(95) .EQ. 0 .AND. id%KEEP(23) .EQ. 0) THEN
!     if max trans desactivated then the automatic choice for type of ord
!     is set to 1, which means that we will use usual ordering
!     (no constraints or compression)
         id%KEEP(95) = 1
      ENDIF
   ELSE
      id%KEEP(95) = 1
   ENDIF
!     --------------------------------
!     Save ICNTL(56) (QR) in KEEP(53)
!     Will be broadcasted to all other
!     nodes in routine @MUMPS_PREFIX@MUMPS_BDCAST
!     --------------------------------
   id%KEEP(53) = id%ICNTL(56)
!     ---------------------------
!     Possible values are 0..2 
!     Other values are treated as 0
!     ------------------------------
   IF ( id%KEEP(53) .LT. 0 .OR. &
  &        id%KEEP(53) .GE. 2 &
  &      ) THEN
      id%KEEP(53) = 0
      IF (PROKG) WRITE(MPG,'(A)') &
  &    ' WARNING: ICNTL(56) treated as if set to 0 '
   END IF
   IF(id%KEEP(86).EQ.1)THEN
!     Force the exchange of both the memory and flops information during 
!     the factorization
      IF(id%KEEP(47).LT.2) id%KEEP(47)=2
   ENDIF
   IF(id%KEEP(48).EQ.5)THEN
      IF(id%KEEP(50).EQ.0)THEN
         id%KEEP(87)=50
         id%KEEP(88)=50
      ELSE
         id%KEEP(87)=70
         id%KEEP(88)=70
      ENDIF
   ENDIF
   IF((id%NSLAVES.EQ.1).AND.(id%KEEP(76).GT.3))THEN
      id%KEEP(76)=2
   ENDIF
   IF(id%KEEP(81).GT.0)THEN
      IF(id%KEEP(47).LT.2) id%KEEP(47)=2
   ENDIF
!
!        -- Save Block Low Rank input parameter 
   id%KEEP(494) = id%ICNTL(35)
   IF (id%KEEP(494).EQ.1) THEN
!        -- Automatic BLR option setting
     id%KEEP(494)= 2
   ENDIF
   IF ( id%KEEP(494).EQ.4) id%KEEP(494)=0
   IF ((id%KEEP(494).LT.0).OR.(id%KEEP(494).GT.4)) THEN
!          Out of range values treated as 0
     id%KEEP(494) = 0
   ENDIF
   IF(id%KEEP(494).NE.0) THEN
!        test BLR incompatibilities
!
    id%KEEP(464) = id%ICNTL(38)
    IF (id%KEEP(464).LT.0.OR.(id%KEEP(464).GT.1000)) THEN
!          Out of range values treated as 0
     id%KEEP(464) = 0
    ENDIF
    id%KEEP(465) = id%ICNTL(39)
    IF (id%KEEP(465).LT.0.OR.(id%KEEP(465).GT.1000)) THEN
!          Out of range values treated as 0
     id%KEEP(465) = 0
    ENDIF
!         LR is incompatible with elemental matrices, forbid it at analysis
    IF (id%KEEP(55).NE.0) THEN
      IF (LPOK) WRITE(LP,*) &
  &           " *** BLR feature currently incompatible " &
  &           ,"with elemental matrices"
!           BLR for elt entry might be developed in the future
      id%INFO(1)=-800
      id%INFO(2)=5
      RETURN
    ENDIF
!
!         LR incompatible with forward in facto 
    IF (id%KEEP(252).NE.0) THEN
      IF (LPOK) WRITE(LP,*) &
  &        " *** BLR feature currently incompatible" &
  &       ," with forward during factorization"
       id%INFO(1) = -43
       id%INFO(2) = 35
       RETURN
    ENDIF
!
   ENDIF
!
   IF(id%KEEP(494).NE.0) THEN
!         id%KEEP(469)=0,1,2,3,4
    IF ((id%KEEP(469).GT.4).OR.(id%KEEP(469).LT.0)) THEN
         id%KEEP(469)=0
    ENDIF
!         Not implemented yet               
    IF (id%KEEP(469).EQ.4) id%KEEP(469)=0
!         id%KEEP(471)=-1,0,1
    IF ((id%KEEP(471).LT.-1).AND.(id%KEEP(471).GT.1)) THEN
         id%KEEP(471)=-1
    ENDIF
!         id%KEEP(472)=0 or 1
    IF ((id%KEEP(472).NE.0).AND.(id%KEEP(472).NE.1)) THEN
         id%KEEP(472)=1
    ENDIF
!         id%KEEP(475)=0,1,2,3
    IF ((id%KEEP(475).GT.3).OR.(id%KEEP(475).LT.0)) THEN
         id%KEEP(475)=0
    ENDIF
!         id%KEEP(482)=0,1,2,3
    IF ((id%KEEP(482).GT.3).OR.(id%KEEP(482).LT.0)) THEN
         id%KEEP(482)=0
    ENDIF
    IF((id%KEEP(487).LT.0)) THEN
       id%KEEP(487)= 2 ! default value
    ENDIF
!         id%KEEP(488)>0
    IF((id%KEEP(488).LE.0)) THEN
        id%KEEP(488)=  8*id%KEEP(6)
    ENDIF
!         id%KEEP(490)>0
    IF((id%KEEP(490).LE.0)) THEN
       id%KEEP(490) = 128
    ENDIF
!         KEEP(491)>0
    IF((id%KEEP(491).LE.0)) THEN
      id%KEEP(491) = 1000
    ENDIF
   ENDIF
! 
id%KEEP(13) = 0
id%KEEP(14) = 0
!     Analysis by Blocks
id%KEEP(13) = id%ICNTL(15)
IF (id%KEEP(13).GT.1) THEN
!V0   out-of range values
  id%KEEP(13) = 0
ENDIF
IF (id%KEEP(13).EQ.1) THEN
!{    Analysis by block with block data provided by user
!     check input data
   IF ( .NOT.associated(id%BLKPTR)) THEN
!        BLKPTR provided by user
    IF ( LPOK ) THEN
       WRITE(LP,'(A,I8)') &
  &       " id%BLKPTR should be provided by user on host "
    ENDIF
    id%INFO(1) = -57
    id%INFO(2) = 2
   ELSE IF ( (id%NBLK.LE.0).OR.(id%NBLK.GT.id%N) &
  &       .OR. (id%NBLK+1.NE.size(id%BLKPTR)) &
  &      ) THEN
!        id%NBLK out of range
     IF ( LPOK ) THEN
       WRITE(LP,'(A,I8)') &
  &       " ERROR incorrect value of id%NBLK:", id%NBLK
     ENDIF
     id%INFO(1) = -57
     id%INFO(2) = 1
   ELSE IF (id%BLKPTR(id%NBLK+1)-1.NE.id%N) THEN
     IF ( LPOK ) THEN
       WRITE(LP,'(A,A,I8)') &
  &       " ERROR id%BLKPTR(id%NBLK+1)-1 ", &
  &       "should be equal to id%N instead of ", &
  &       id%BLKPTR(id%NBLK+1)-1
     ENDIF
     id%INFO(1) = -57
     id%INFO(2) = 2
   ELSE IF (id%BLKPTR(1).NE.1) THEN
     IF ( LPOK ) THEN
       WRITE(LP,'(A,A,I8)') &
  &       " ERROR id%BLKPTR(1)", &
  &       "should be equal to 1 instead of ", &
  &       id%BLKPTR(1)
     ENDIF
     id%INFO(1) = -57
     id%INFO(2) = 2
   ELSE IF (associated(id%BLKVAR)) THEN
!        id%BLKVAR
     IF (size(id%BLKVAR).NE.id%N) THEN
       IF ( LPOK ) THEN
        WRITE(LP,'(A,A,I8)') &
  &        " ERROR with centralized matrix. Size of id%BLKVAR ", &
  &        "should be equal to id%N instead of ", &
  &        size(id%BLKVAR)
       ENDIF
       id%INFO(1) = -57
       id%INFO(2) = 3
     ENDIF
   ENDIF
!}
ENDIF
IF (id%KEEP(13).LT.0) THEN
!       note that id%BLKPTR might still be associated
!       but will not be used
  IF (mod(id%N,-id%KEEP(13)) .NE.0) THEN
    IF ( LPOK ) THEN
       WRITE(LP,'(A,I8)') &
  &       " ICNTL(15)=", id%ICNTL(15), &
  &       " is incompatible with N=", id%N
    ENDIF
    id%INFO(1) = -57
    id%INFO(2) = 1
  ENDIF
ENDIF
IF (id%KEEP(13).EQ.0) THEN
 IF ( &
  &      ((id%KEEP(54).EQ.3).AND.(id%KEEP(244).EQ.1)) &
  &      .OR. &
  &      ((id%KEEP(244).EQ.2).AND.(id%KEEP(339).NE.0)) &
  &     ) THEN
    id%KEEP(13)=-1
 ENDIF
!      unsymmetric assembled matrices with or without BLR,
!      also in case of centralized matrix (if
!      matrix is distributed, then KEEP(13) has
!      been set to -1 in the block above)
 IF (id%KEEP(50).EQ.0.AND. id%KEEP(55).EQ.0) THEN
!         Respect decision taken for Maxtrans
!         since it will be switch off 
!         if one activates the analysis by block
    IF ( (id%KEEP(23).LE.0) .OR. (id%KEEP(23).GT.7) &
  &       ) THEN
       id%KEEP(13)=-1
    ENDIF
 ENDIF
ENDIF
IF ( (id%KEEP(13).NE.0)  .AND. &
  &     (id%KEEP(55).NE.0) &
  &   ) THEN
   IF (PROKG.AND.(id%KEEP(13).NE.-1)) WRITE(MPG,'(A,A)') &
  &           " ** Analysis by block is incompatible ", &
  &           "with elemental matrices"
!           switch off analysis by block
      id%KEEP(13)= 0
ENDIF
IF ( (id%KEEP(13).NE.0) .AND. &
  &     (id%KEEP(106).NE.1).AND. (id%KEEP(106).NE.2) &
  &   ) THEN
   IF (PROKG.AND.(id%KEEP(13).NE.-1)) WRITE(MPG,'(A,A,I4)') &
  &      " ** Analysis by block not compatible ", &
  &      "with symbolic factorization option  ", &
  &           id%KEEP(106)
!           switch off analysis by block
      id%KEEP(13)= 0
ENDIF
IF ( (id%KEEP(13).NE.0) .AND. (id%KEEP(244) .EQ. 2) .AND. &
  &     (id%KEEP(339).EQ.0) &
  &   ) THEN
   IF (PROKG.AND.(id%KEEP(13).NE.-1)) WRITE(MPG,'(A)') &
  &           " ** Analysis by block switched off "
!           switch off analysis by block
      id%KEEP(13)= 0
ENDIF
IF ( (id%KEEP(13).NE.0) .AND. &
  &     (id%KEEP(60).NE.0) &
  &   ) THEN
   IF (PROKG.AND.(id%KEEP(13).NE.-1)) WRITE(MPG,'(A,A)') &
  &           " ** Analysis by block is incompatible ", &
  &           "with Schur "
!           switch off analysis by block
      id%KEEP(13)= 0
ENDIF
IF (id%KEEP(13).NE.0) THEN
!      Maximum transversal not compatible with analysis by block
 IF (id%KEEP(23).NE.0) THEN
!        in case of automatic choice (id%KEEP(27).EQ.7)
!        do not print message
   IF (PROKG.AND.id%KEEP(23).NE.7) WRITE(MPG,'(A,A)') &
  &      " ** Maximum transversal (ICNTL(6)) ", &
  &      "not compatible with analysis by block"
!        switch off max transversal
   id%KEEP(23)= 0
 ENDIF
!      - compression for LDLT
 IF (id%KEEP(95).NE.1) THEN
!        in case of automatic choice (id%KEEP(95).EQ.0)
!        do not print message
   IF (PROKG.AND.id%KEEP(95).NE.0) WRITE(MPG,'(A,A)') &
  &      " ** ICNTL(12) not compatible with ", &
  &      " analysis by block"
!        switch off 2x2 preprocessing for symmetric matrices
   id%KEEP(95) = 1
 ENDIF
ENDIF
!
!     end id%MYID.EQ.MASTER 
END IF
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_ANA_CHECK_KEEP
!     ========================================
SUBROUTINE @MUMPS_PREFIX@MUMPS_ANA_CHECK_ICNTL48 (id )
!$    USE OMP_LIB, ONLY : omp_get_max_threads
USE @MUMPS_PREFIX@MUMPS_STRUC_DEF
!
IMPLICIT NONE
!
!  Purpose
!  =======
!  This subroutine performed part of @MUMPS_PREFIX@MUMPS_ANA_CHECK_KEEP concerned by ICNTL(48) 
!  and is called by @MUMPS_PREFIX@MUMPS_ANA_CHECK_KEEP  and  @MUMPS_PREFIX@MUMPS_ANA_REDO_STAT
!
!     Parameters 
! 
TYPE(@MUMPS_PREFIX@MUMPS_STRUC)  :: id
!
!     Local variables
!
INTEGER   :: LP, MP, MPG, NOMP
INTEGER   :: MASTER
LOGICAL   :: PROK, PROKG, LPOK
LOGICAL   :: I_AM_SLAVE
PARAMETER( MASTER = 0 )
!
LP  = id%ICNTL( 1 )
MP  = id%ICNTL( 2 )
MPG = id%ICNTL( 3 )
!     LP     : errors
!     MP     : INFO
LPOK  = ((LP.GT.0).AND.(id%ICNTL(4).GE.1))
PROK  = (( MP  .GT. 0 ).AND.(id%ICNTL(4).GE.2))
PROKG = ( MPG .GT. 0 .and. id%MYID .eq. MASTER )
PROKG = (PROKG.AND.(id%ICNTL(4).GE.2))
I_AM_SLAVE = ( id%MYID .ne. MASTER  .OR. &
  &     ( id%MYID .eq. MASTER .AND. &
  &     id%KEEP(46) .eq. 1 ) )
IF (id%MYID.eq.MASTER) THEN
!
!       L0-OMP settings of KEEP(400)
!
  id%KEEP(401) = 0
  NOMP = 0
  IF (id%ICNTL(48).EQ.1) id%KEEP(401)=1
  IF (id%KEEP(401) .GT. 0) THEN
!$        NOMP=omp_get_max_threads()
    IF ( NOMP .EQ. 0 ) THEN
!           Compilation without OMP!
      id%KEEP(400) = 0
      id%INFO(1)=-58
      id%INFO(2)=0
      IF (LPOK) WRITE(LP,'(A)') &
  &      " FAILURE DETECTED IN ANALYSIS: ICNTL(48) requires OpenMP"
      RETURN
    ENDIF
  ENDIF
!
ENDIF
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_ANA_CHECK_ICNTL48
!
SUBROUTINE @MUMPS_PREFIX@MUMPS_GATHER_MATRIX(id)
!     This subroutine gathers a distributed matrix
!     on the host node 
USE @MUMPS_PREFIX@MUMPS_STRUC_DEF
IMPLICIT NONE
INCLUDE 'mpif.h'
INCLUDE 'mumps_tags.h'
INTEGER IERR, MASTER
PARAMETER( MASTER = 0 )
INTEGER :: STATUS(MPI_STATUS_SIZE)
TYPE(@MUMPS_PREFIX@MUMPS_STRUC)  :: id
!     local variables
INTEGER, ALLOCATABLE :: REQPTR(:,:)
INTEGER(8), ALLOCATABLE :: MATPTR(:)
INTEGER(8), ALLOCATABLE :: MATPTR_cp(:)
INTEGER(8)           :: IBEG8, IEND8
INTEGER              :: INDX
INTEGER              :: LP, MP, MPG, I, K
INTEGER(8)           :: I8
LOGICAL              :: PROKG
!     
!     messages are split into blocks of size BLOCKSIZE
!               (smaller than IOVFLO (=2^31-1))
!     on all processors
INTEGER(4)           :: IOVFLO
INTEGER              :: BLOCKSIZE
INTEGER              :: MAX_NBBLOCK_loc, NBBLOCK_loc
INTEGER              :: SIZE_SENT, NRECV
LOGICAL              :: OMP_FLAG
INTEGER(8)           :: NZ_loc8
!     for validation only:
INTEGER              :: NB_BLOCKS, NB_BLOCK_SENT
LP  = id%ICNTL( 1 )
MP  = id%ICNTL( 2 )
MPG = id%ICNTL( 3 )
!     LP     : errors
!     MP     : INFO
PROKG = ( MPG .GT. 0 .and. id%MYID .eq. MASTER )
PROKG = (PROKG.AND.(id%ICNTL(4).GE.2))
!     iovflo = huge(INTEGER, kind=4)
IOVFLO = huge(IOVFLO)
!     we do not want too large messages
BLOCKSIZE = int(max(100000_8,int(IOVFLO,8)/200_8))
IF ( id%KEEP(46) .EQ. 0 .AND. id%MYID .EQ. MASTER ) THEN
!     host-node mode: master has no entries.
   id%KEEP8(29) = 0_8
END IF
IF ( id%MYID .eq. MASTER ) THEN
!     -----------------------------------
!     Allocate small arrays for pointers
!     into arrays IRN/JCN
!     -----------------------------------
   ALLOCATE( MATPTR( id%NPROCS ), STAT = IERR )
   IF ( IERR .GT. 0 ) THEN
      id%INFO(1) = -7
      id%INFO(2) =  id%NPROCS
      IF ( LP .GT. 0 ) THEN
         WRITE(LP, 150) ' array MATPTR'
      END IF
      GOTO 13
   END IF
   ALLOCATE( MATPTR_cp( id%NPROCS ), STAT = IERR )
   IF ( IERR .GT. 0 ) THEN
      id%INFO(1) = -7
      id%INFO(2) =  id%NPROCS
      IF ( LP .GT. 0 ) THEN
         WRITE(LP, 150) ' array MATPTR'
      END IF
      GOTO 13
   END IF
!     -----------------------------------
!     Allocate a small array for requests
!     -----------------------------------
   ALLOCATE( REQPTR( id%NPROCS-1, 2 ), STAT = IERR )
   IF ( IERR .GT. 0 ) THEN
      id%INFO(1) = -7
      id%INFO(2) = 2 * (id%NPROCS-1)
      IF ( LP .GT. 0 ) THEN
         WRITE(LP, 150) 'array REQPTR'
      END IF
      GOTO 13
   END IF
!     --------------------
!     Allocate now IRN/JCN
!     --------------------
   ALLOCATE( id%IRN( id%KEEP8(28) ), STAT = IERR )
   IF ( IERR .GT. 0 ) THEN
      id%INFO(1) = -7
      CALL MUMPS_SETI8TOI4(id%KEEP8(28),id%INFO(2))
      IF ( LP .GT. 0 ) THEN
         WRITE(LP, 150) 'array IRN'
      END IF
      GOTO 13
   END IF
   ALLOCATE( id%JCN( id%KEEP8(28) ), STAT = IERR )
   IF ( IERR .GT. 0 ) THEN
      id%INFO(1) = -7
      CALL MUMPS_SETI8TOI4(id%KEEP8(28),id%INFO(2))
      IF ( LP .GT. 0 ) THEN
         WRITE(LP, 150) 'array JCN'
      END IF
      GOTO 13
   END IF
END IF
13 CONTINUE
!     Propagate errors
CALL MUMPS_PROPINFO( id%ICNTL(1), id%INFO(1), &
  &     id%COMM, id%MYID )
IF ( id%INFO(1) < 0 ) RETURN
!     -------------------------------------
!     Get numbers of non-zeros for everyone
!     and count total and maximum 
!     nb of blocks of size BLOCKSIZE
!     that slaves will sent
!     -------------------------------------
IF ( id%MYID .EQ. MASTER ) THEN
!        each block will correspond to 2 messages (IRN_LOC,JCN_LOC)
   NB_BLOCK_SENT = 0
   MAX_NBBLOCK_loc  = 0
   DO I = 1, id%NPROCS - 1
      CALL MPI_RECV( MATPTR( I+1 ), 1, &
  &           MPI_INTEGER8, I, &
  &           COLLECT_NZ, id%COMM, STATUS, IERR )
      NBBLOCK_loc = ceiling(dble(MATPTR(I+1))/dble(BLOCKSIZE))
      MAX_NBBLOCK_loc = max(MAX_NBBLOCK_loc, NBBLOCK_loc)
      NB_BLOCK_SENT = NB_BLOCK_SENT + NBBLOCK_loc
   END DO
   IF ( id%KEEP(46) .eq. 0 ) THEN
      MATPTR( 1 ) = 1_8
   ELSE
      NZ_loc8=id%KEEP8(29)
      MATPTR( 1 ) = NZ_loc8 + 1_8
   END IF
!     --------------
!     Build pointers
!     --------------
   DO I = 2, id%NPROCS
      MATPTR( I ) = MATPTR( I ) + MATPTR( I-1 )
   END DO
ELSE
   NZ_loc8=id%KEEP8(29)
   CALL MPI_SEND( NZ_loc8, 1, MPI_INTEGER8, MASTER, &
  &        COLLECT_NZ, id%COMM, IERR )
END IF
IF ( id%MYID .eq. MASTER  ) THEN
!     -----------------------------------------------
!     Bottleneck is here master; use synchronous send
!     for slaves, but asynchronous receives on master
!     Then while master receives indices do the local
!     copies for better overlap. 
!     (If master has other things to do, he could try
!     to do them here.)
!     ------------------------------------
!       copy pointers to position in IRN/JCN 
  MATPTR_cp = MATPTR
  IF ( id%KEEP8(29) .NE. 0_8 ) THEN
      OMP_FLAG = ( id%KEEP8(29).GE.50000_8 )
!$OMP PARALLEL DO PRIVATE(I8)
!$OMP&         IF(OMP_FLAG)
      DO I8=1,id%KEEP8(29)
         id%IRN(I8) = id%IRN_loc(I8)
         id%JCN(I8) = id%JCN_loc(I8)
      ENDDO
!$OMP END PARALLEL DO
  ENDIF
!
!     Compute position for each block to be received
!     and store it.
  NB_BLOCKS = 0
!       at least one slave will send MAX_NBBLOCK_loc 
!       couple of messages (IRN_loc/JCN_loc)
  DO K = 1, MAX_NBBLOCK_loc
!        Post irecv for all messages from proc I 
!        that have been sent
   NRECV = 0
   DO I = 1, id%NPROCS - 1
!           Check if message was sent
      IBEG8     = MATPTR_cp( I )
      IF ( IBEG8 .LT. MATPTR(I+1))  THEN
!             Count number of request in NRECV
        NRECV = NRECV + 2
        IEND8 = min(IBEG8+int(BLOCKSIZE,8)-1_8, &
  &                    MATPTR(I+1)-1_8)
!             update pointer for receiving messages
!             from proc I in MATPTR_cp:
        MATPTR_cp( I ) = IEND8 + 1_8
        SIZE_SENT   = int(IEND8 -  IBEG8 + 1_8)
        NB_BLOCKS   = NB_BLOCKS + 1
!
        CALL MPI_IRECV( id%IRN(IBEG8), SIZE_SENT, MPI_INTEGER, &
  &           I, COLLECT_IRN, id%COMM, REQPTR(I,1), IERR )
!
        CALL MPI_IRECV( id%JCN(IBEG8), SIZE_SENT, MPI_INTEGER, &
  &           I, COLLECT_JCN, id%COMM, REQPTR(I,2), IERR )
      ELSE
       REQPTR( I,1 ) = MPI_REQUEST_NULL
       REQPTR( I,2 ) = MPI_REQUEST_NULL
      ENDIF
   END DO
!        Wait set of messages corresponding to current block
!        ( we dont exploit the fact that 
!            messages are not overtaking 
!            (if sent by one source to the same destination)  )
!
!        Loop on only non MPI_REQUEST_NULL requests
   DO I = 1, NRECV
       CALL MPI_WAITANY &
  &           ( 2 * (id%NPROCS-1), REQPTR( 1, 1 ), INDX, &
  &           STATUS, IERR )
   ENDDO
!
!       process next block
END DO
  DEALLOCATE( REQPTR )
  DEALLOCATE( MATPTR )
  DEALLOCATE( MATPTR_cp )
!     end of reception by master
ELSE
!     -----------------------------
!     Send only if size is not zero
!     -----------------------------
   IF ( id%KEEP8(29) .NE. 0_8 ) THEN
     NZ_loc8=id%KEEP8(29)
!          send by blocks of size BLOCKSIZE
     DO I8=1_8, NZ_loc8, int(BLOCKSIZE,8)
      SIZE_SENT = BLOCKSIZE
      IF (NZ_loc8-I8+1_8.LT.int(BLOCKSIZE,8)) THEN
        SIZE_SENT = int(NZ_loc8-I8+1_8)
      ENDIF
      CALL MPI_SEND( id%IRN_loc(I8), SIZE_SENT, &
  &           MPI_INTEGER, MASTER, &
  &           COLLECT_IRN, id%COMM, IERR )
      CALL MPI_SEND( id%JCN_loc(I8), SIZE_SENT, &
  &           MPI_INTEGER, MASTER, &
  &           COLLECT_JCN, id%COMM, IERR )
     END DO
   END IF
END IF
RETURN
150 FORMAT( &
  &/' ** FAILURE DURING @MUMPS_PREFIX@MUMPS_GATHER_MATRIX, DYNAMIC ALLOCATION OF', &
  &     A30)
END SUBROUTINE @MUMPS_PREFIX@MUMPS_GATHER_MATRIX
SUBROUTINE @MUMPS_PREFIX@MUMPS_DUMP_PROBLEM(id)
USE @MUMPS_PREFIX@MUMPS_STRUC_DEF
IMPLICIT NONE
!
!     Purpose:
!     =======
!
!     If id%WRITE_PROBLEM has been set by the user,
!     possibly on all processors in case of distributed
!     matrix, open a file and dumps the matrix and/or
!     the right hand side. In case the last characters
!     of id.WRITE_PROBLEM are "bin" (uppercase letters
!     are also accepted), then the matrix is written
!     in binary stream format (a C routine is called to
!     avoid depending on the access='stream' mode that
!     is only available since Fortran 2003). In that case,
!     a small header file is also written.
!     Otherwise, this subroutine calls
!     @MUMPS_PREFIX@MUMPS_DUMP_MATRIX (to write the matrix in
!     matrix-market format) and @MUMPS_PREFIX@MUMPS_DUMP_RHS.
!     The routine should be called on all MPI processes.
!
!     Examples:
!     1/ WRITE_PROBLEM='mymatrix.txt', centralized matrix
!       mymatrix.txt contains the matrix in matrix-market format
!     2/ WRITE_PROBLEM='mymatrix.txt', distributed matrix
!       mymatrix.txt<i> contains the portion of the matrix
!       on process <i>, in matrix-market format
!     3/ WRITE_PROBLEM='mymatrix.bin', centralized matrix
!       mymatrix.bin contains the matrix in binary format
!       mymatrix.header contains a short description in text format,
!                       with the first line identical to the one of
!                       a matrix-market format
!     4/ WRITE_PROBLEM='mymatrix.bin', distributed matrix
!       mymatrix.bin<i> contains the portion of the matrix
!                       on process <i>, in binary format
!
!       mymatrix.header contains a short description in text format,
!          with the first line identical to matrix-market format
!
!     If a centralized, dense, RHS is available, it is also written,
!     either in matrix-market or binary format (if WRITE_PROBLEM
!     has a .bin extension). In that case the filename for the RHS
!     is WRITE_PROBLEM//".rhs". If written in binary form, information
!     on the RHS is also provided in the header file.
!
INCLUDE 'mpif.h'
!
!     Arguments
!     =========
!
TYPE(@MUMPS_PREFIX@MUMPS_STRUC)  :: id
!
!     Local variables
!     ===============
!
INTEGER              :: MASTER, IERR, I
INTEGER              :: IUNIT
LOGICAL              :: IS_ELEMENTAL
LOGICAL              :: IS_DISTRIBUTED
LOGICAL              :: NAME_INITIALIZED
INTEGER              :: DO_WRITE, DO_WRITE_CHECK
CHARACTER(LEN=20)    :: IDSTR
LOGICAL              :: I_AM_SLAVE, I_AM_MASTER
INTEGER              :: L
LOGICAL              :: BINARY_FORMAT, DUMP_RHS, &
  &                        DUMP_BLKPTR, DUMP_BLKVAR
INTEGER              :: IS_A_PROVIDED, IS_A_PROVIDED_GLOB
COMPLEX, TARGET                :: A_DUMMY(1)
INTEGER, TARGET                :: IRN_DUMMY(1), JCN_DUMMY(1)
INTEGER, POINTER, DIMENSION(:) :: IRN_PASSED, JCN_PASSED
COMPLEX, POINTER, DIMENSION(:) :: A_PASSED
INTEGER              :: MPG
LOGICAL              :: PROKG
PARAMETER( MASTER = 0 )
I_AM_SLAVE = ( id%MYID .NE. MASTER  .OR. &
  &     ( id%MYID .EQ. MASTER .AND. &
  &     id%KEEP(46) .EQ. 1 ) )
I_AM_MASTER = (id%MYID.EQ.MASTER)
MPG = id%ICNTL( 3 )
PROKG = ( MPG .GT. 0 .and. id%MYID .eq. MASTER )
PROKG = (PROKG.AND.(id%ICNTL(4).GE.2))
NAME_INITIALIZED = id%WRITE_PROBLEM(1:20) &
  &     .NE. "NAME_NOT_INITIALIZED"
BINARY_FORMAT = .FALSE.
L=len_trim(id%WRITE_PROBLEM)
IF (L.GT.4) THEN
  IF ( id%WRITE_PROBLEM(L-3:L-3) .EQ. '.' .AND. &
  &       ( id%WRITE_PROBLEM(L-2:L-2) .EQ. 'b' .OR. &
  &         id%WRITE_PROBLEM(L-2:L-2) .EQ. 'B' ) .AND. &
  &       ( id%WRITE_PROBLEM(L-1:L-1) .EQ. 'i' .OR. &
  &         id%WRITE_PROBLEM(L-1:L-1) .EQ. 'I' ) .AND. &
  &       ( id%WRITE_PROBLEM(L:L) .EQ. 'n' .OR. &
  &         id%WRITE_PROBLEM(L:L) .EQ. 'N' ) ) THEN
    BINARY_FORMAT = .TRUE.
  ENDIF
ENDIF
IF (NAME_INITIALIZED.AND.PROKG) THEN
  WRITE(MPG,'(/A,A/)') &
  &    " Write input matrix to file, WRITE_PROBLEM= ", &
  &    id%WRITE_PROBLEM(1:L)
ENDIF
!     Check if RHS should also be dumped
DUMP_RHS = id%MYID.EQ.MASTER .AND. &
  &     associated(id%RHS) .AND. NAME_INITIALIZED
DUMP_RHS = DUMP_RHS .AND. id%NRHS .GE. 1
DUMP_RHS = DUMP_RHS .AND. id%N .GE. 1
DUMP_RHS = DUMP_RHS .AND. id%ICNTL(20) .EQ. 0
!     Check if BLKPTR and/or BLKVAR should also be dumped
DUMP_BLKPTR = .FALSE.
DUMP_BLKVAR = .FALSE.
IF ( id%MYID.EQ.MASTER .AND. NAME_INITIALIZED ) THEN
  IF ( id%ICNTL(15) .EQ. 1 &
  &      .AND. id%NBLK .GT. 0 ) THEN
    IF (associated(id%BLKPTR)) THEN
      DUMP_BLKPTR = .TRUE.
      IF (associated(id%BLKVAR)) THEN
!           Dump also BLKVAR, except if allocated by MUMPS
      DUMP_BLKVAR = .TRUE.
      ENDIF
    ENDIF
  ELSE IF ( id%ICNTL(15) .LT. 0 ) THEN
    IF (associated(id%BLKVAR)) THEN
!           Dump also BLKVAR, except if allocated by MUMPS
      DUMP_BLKVAR = .TRUE.
    ENDIF
  ENDIF
ENDIF
!     Remark: if id%KEEP(54) = 1 or 2, the structure
!     is centralized at analysis. Since @MUMPS_PREFIX@MUMPS_DUMP_PROBLEM
!     is called at analysis phase, we define IS_DISTRIBUTED
!     as below, which implies that the structure of the problem
!     is distributed in IRN_loc/JCN_loc at analysis.
IS_DISTRIBUTED = (id%KEEP(54) .EQ. 3)
IS_ELEMENTAL   = (id%KEEP(55) .NE. 0)
IF (NAME_INITIALIZED) THEN
  IF (I_AM_MASTER .OR. IS_DISTRIBUTED) THEN
!         Try to find a free Fortran unit
    CALL MUMPS_FIND_UNIT(IUNIT)
    IF ( IUNIT .EQ. -1 ) THEN
      id%INFO(1) = -79
      id%INFO(2) = 1
    ENDIF
  ENDIF
ENDIF
CALL MUMPS_PROPINFO( id%ICNTL(1), id%INFO(1), &
  &     id%COMM, id%MYID )
IF (id%INFO(1) .LT. 0) GOTO 500
IF (I_AM_MASTER .AND. .NOT. IS_DISTRIBUTED) THEN
!        ====================
!        Matrix is assembled
!        and centralized
!        ====================
  IF (NAME_INITIALIZED) THEN
    IF ( BINARY_FORMAT ) THEN
      IF (id%KEEP8(28) .EQ. 0_8) THEN
!             Special case of empty matrix
        A_PASSED   => A_DUMMY
        IRN_PASSED => IRN_DUMMY
        JCN_PASSED => JCN_DUMMY
        IS_A_PROVIDED = 1
      ELSE IF (associated(id%A)) THEN
        A_PASSED=>id%A
        IRN_PASSED => id%IRN
        JCN_PASSED => id%JCN
        IS_A_PROVIDED = 1
      ELSE
        A_PASSED => A_DUMMY
        IRN_PASSED => id%IRN
        JCN_PASSED => id%JCN
        IS_A_PROVIDED = 0
      ENDIF
      OPEN( IUNIT, FILE=id%WRITE_PROBLEM(1:L-4)//'.header' )
      CALL @MUMPS_PREFIX@MUMPS_DUMP_HEADER( IUNIT, id%N, &
  &      IS_A_PROVIDED, id%KEEP(50), IS_DISTRIBUTED, &
  &      id%NSLAVES, id%KEEP8(28), DUMP_RHS, id%NRHS, &
  &      DUMP_BLKPTR, DUMP_BLKVAR, id%NBLK, id%ICNTL(15) )
      CLOSE( IUNIT )
!           type of numerical values should be the type 
!           of the matrix values as provided by the user
      CALL MUMPS_DUMPMATBINARY_C( id%N, id%KEEP8(28), &
  &      id%KEEP(149), &
  &      IRN_PASSED(1), JCN_PASSED(1), A_PASSED(1), &
  &      IS_A_PROVIDED, &
  &      trim(id%WRITE_PROBLEM)//char(0) )
    ELSE
      OPEN(IUNIT,FILE=trim(id%WRITE_PROBLEM))
      CALL @MUMPS_PREFIX@MUMPS_DUMP_MATRIX( id, IUNIT, I_AM_SLAVE, I_AM_MASTER, &
  &         IS_DISTRIBUTED,  ! = .FALSE., centralized &
  &         IS_ELEMENTAL,    ! Elemental or not &
  &         .FALSE.)
      CLOSE(IUNIT)
    ENDIF
  ENDIF
ELSE IF ( IS_DISTRIBUTED ) THEN
!        =====================
!        Matrix is distributed
!        =====================
   IF ( .NOT.NAME_INITIALIZED &
  &        .OR. .NOT. I_AM_SLAVE )THEN
      DO_WRITE = 0
   ELSE
      DO_WRITE = 1
   ENDIF
   CALL MPI_ALLREDUCE(DO_WRITE, DO_WRITE_CHECK, 1, &
  &        MPI_INTEGER, MPI_SUM, id%COMM, IERR)
!        -----------------------------------------
!        If yes, each processor writes its share
!        of the matrix in a file in matrix market
!        format (otherwise nothing written). We
!        append the process id to the filename.
!        Safer in case all filenames are the
!        same if all processors share the same
!        file system.
!        -----------------------------------------
   IF (DO_WRITE_CHECK.EQ.id%NSLAVES .AND. I_AM_SLAVE) THEN
      WRITE(IDSTR,'(I9)') id%MYID_NODES
      IF (BINARY_FORMAT) THEN
        IF (id%KEEP8(29) .EQ. 0_8) THEN
!               Special case of empty matrix
          A_PASSED   => A_DUMMY
          IRN_PASSED => IRN_DUMMY
          JCN_PASSED => JCN_DUMMY
!               (consider that A is provided when NNZ_loc=0)
          IS_A_PROVIDED = 1
        ELSE IF (associated(id%A_loc)) THEN
          A_PASSED=>id%A_loc
          IRN_PASSED => id%IRN_loc
          JCN_PASSED => id%JCN_loc
          IS_A_PROVIDED = 1
        ELSE
          A_PASSED => A_DUMMY
          IRN_PASSED => id%IRN_loc
          JCN_PASSED => id%JCN_loc
          IS_A_PROVIDED = 0
        ENDIF
        CALL MPI_ALLREDUCE( IS_A_PROVIDED, &
  &             IS_A_PROVIDED_GLOB, 1, &
  &             MPI_INTEGER, MPI_PROD, id%COMM_NODES, IERR )
!             IS_A_PROVIDED_GLOB = 1 => dump numerical values
!             IS_A_PROVIDED_GLOB = 0 => some processes did not provide
!                                   numerical values, dump only pattern,
!                                   and indicate this in the header
        IF ( id%MYID_NODES.EQ.0) THEN
!               Print header on first MPI worker (only one global header
!               file in case of distributed matrix), replacing the .bin
!               extension by a .header extension
          OPEN( IUNIT, FILE=id%WRITE_PROBLEM(1:L-4)//'.header' )
          CALL @MUMPS_PREFIX@MUMPS_DUMP_HEADER( IUNIT, id%N, &
  &          IS_A_PROVIDED_GLOB, id%KEEP(50), IS_DISTRIBUTED, &
  &          id%NSLAVES, id%KEEP8(28), DUMP_RHS, id%NRHS, &
  &          DUMP_BLKPTR, DUMP_BLKVAR, id%NBLK, id%ICNTL(15) )
          CLOSE( IUNIT )
        ENDIF
!             type of numerical values should be the type 
!             of the matrix values as provided by the user
        CALL MUMPS_DUMPMATBINARY_C( id%N, id%KEEP8(29), &
  &        id%KEEP(149), &
  &        IRN_PASSED(1), JCN_PASSED(1), A_PASSED(1), &
  &        IS_A_PROVIDED_GLOB, &
  &        trim(id%WRITE_PROBLEM)//trim(adjustl(IDSTR))//char(0) )
      ELSE
        OPEN(IUNIT, &
  &             FILE=trim(id%WRITE_PROBLEM)//trim(adjustl(IDSTR)))
        CALL @MUMPS_PREFIX@MUMPS_DUMP_MATRIX(id, &
  &           IUNIT, I_AM_SLAVE, I_AM_MASTER, &
  &           IS_DISTRIBUTED,           ! =.TRUE., distributed &
  &           IS_ELEMENTAL,             ! Elemental or not &
  &           .FALSE.)
        CLOSE(IUNIT)
      ENDIF
   ENDIF
!     ELSE ...
!     Nothing written in other cases.
ENDIF
!     ===============
!     Right-hand side
!     ===============
IF ( DUMP_RHS ) THEN
  IF (BINARY_FORMAT) THEN
!         dump RHS in binary format
!         type of numerical values should be the type 
!         of the RHS as provided by the user
    CALL MUMPS_DUMPRHSBINARY_C( id%N, id%NRHS, id%LRHS, id%RHS(1), &
  &    id%KEEP(149), &
  &    trim(id%WRITE_PROBLEM)//'.rhs'//char(0) )
  ELSE
!         dump RHS in matrix-market format
    OPEN(IUNIT,FILE=trim(id%WRITE_PROBLEM) //".rhs")
    CALL @MUMPS_PREFIX@MUMPS_DUMP_RHS(IUNIT, id)
    CLOSE(IUNIT)
  ENDIF
ENDIF
IF ( DUMP_BLKPTR ) THEN
    IF (BINARY_FORMAT) THEN
!           suppress trailing '.bin' and use '.blkptr'
      OPEN( IUNIT, FILE=id%WRITE_PROBLEM(1:L-4)//'.blkptr' )
    ELSE
!           just append '.blkptr'
      OPEN(IUNIT,FILE=trim(id%WRITE_PROBLEM)//".blkptr")
    ENDIF
    WRITE(IUNIT,'(I9)') id%NBLK
    DO I=1,id%NBLK+1
      WRITE(IUNIT,'(I9)') id%BLKPTR(I)
    ENDDO
    CLOSE(IUNIT)
ENDIF
IF ( DUMP_BLKVAR ) THEN
    IF (BINARY_FORMAT) THEN
!           suppress trailing '.bin' and use '.blkvar'
      OPEN( IUNIT, FILE=id%WRITE_PROBLEM(1:L-4)//'.blkvar' )
    ELSE
!           just append '.blkvar'
      OPEN(IUNIT,FILE=trim(id%WRITE_PROBLEM)//".blkvar")
    ENDIF
    DO I=1,id%N
      WRITE(IUNIT,'(I9)') id%BLKVAR(I)
    ENDDO
    CLOSE(IUNIT)
ENDIF
500 CONTINUE
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_DUMP_PROBLEM
SUBROUTINE @MUMPS_PREFIX@MUMPS_DUMP_HEADER( IUNIT, N, IS_A_PROVIDED_GLOB, &
  &  SYM, IS_DISTRIBUTED, NSLAVES, NNZTOT, DUMP_RHS, NRHS, &
  &  DUMP_BLKPTR, DUMP_BLKVAR, NBLK, ICNTL15 )
!
!  Purpose:
!  =======
!
!  Write a small header file, similar to matrix-market headers,
!  to accompany a matrix written in binary format.
!
INTEGER, INTENT(IN) :: IUNIT, N, IS_A_PROVIDED_GLOB , SYM, NSLAVES
INTEGER(8), INTENT(IN) :: NNZTOT
LOGICAL, INTENT(IN) :: IS_DISTRIBUTED, DUMP_RHS
INTEGER, INTENT(IN) :: NRHS
LOGICAL, INTENT(IN) :: DUMP_BLKPTR, DUMP_BLKVAR
INTEGER, INTENT(IN) :: NBLK
INTEGER, INTENT(IN) :: ICNTL15
!
!  Local declarations:
!  ==================
!
CHARACTER (LEN=10)   :: SYMM
CHARACTER (LEN=8)    :: ARITH
!     1/ write a line identical to first line of matrix-market header
IF ( IS_A_PROVIDED_GLOB .EQ. 1 ) THEN
    ARITH='@MUMPS_ARITH@'
ELSE
  ARITH='pattern'
ENDIF
IF (SYM .eq. 0) THEN
  SYMM="general"
ELSE
  SYMM="symmetric"
END IF
WRITE(IUNIT,'(A,A,A,A)') '%%MatrixMarket matrix coordinate ', &
  &           trim(ARITH)," ",trim(SYMM)
!     2/ indicate if matrix is distributed or centralized,
!     then describe binary file content and format
IF ( IS_DISTRIBUTED ) THEN
  WRITE(IUNIT,FMT='(A,I5,A)') &
  &  '% Matrix is distributed (MPI ranks=',NSLAVES,')'
ELSE
  WRITE(IUNIT,FMT='(A)') &
  &  '% Matrix is centralized'
ENDIF
WRITE(IUNIT,FMT='(A)') &
  &    '% Unformatted stream IO (no record boundaries):'
IF (ARITH(1:7).EQ.'pattern') THEN
  IF (IS_DISTRIBUTED) THEN
    WRITE(IUNIT,'(A)') &
  &    '%    N,NNZ_loc,IRN_loc(1:NNZ_loc),JCN_loc(1:NNZ_loc)'
  ELSE
    WRITE(IUNIT,'(A)') &
  &    '%    N,NNZ,IRN(1:NNZ),JCN(1:NNZ)'
  ENDIF
  WRITE(IUNIT,'(A)') '%    (numerical values not provided)'
ELSE
  IF (IS_DISTRIBUTED) THEN
    WRITE(IUNIT,'(A)') &
  &    '%    N,NNZ_loc,IRN_loc(1:NNZ_loc),JCN_loc(1:NNZ_loc),'// &
  &    'A_loc(1:NNZ_loc)'
  ELSE
    WRITE(IUNIT,'(A)') '%    N/NNZ/IRN(1:NNZ),JCN(1:NNZ),A(1:NNZ)'
  ENDIF
  WRITE(IUNIT,'(A)') '%    Single complex storage'
ENDIF
IF ( IS_DISTRIBUTED ) THEN
  WRITE(IUNIT,'(A,/,A)') &
  &  '%    N,IRN_loc(i),JCN_loc(i): 32 bits', &
  &  '%    NNZ_loc: 64 bits'
ELSE
  WRITE(IUNIT,'(A,/,A)') &
  &  '%    N,IRN(i),JCN(i): 32 bits', &
  &  '%    NNZ: 64 bits'
ENDIF
WRITE(IUNIT,FMT='(A,I16)') '% Matrix order: N=',N
WRITE(IUNIT,FMT='(A,I16)') '% Matrix nonzeros: NNZ=',NNZTOT
IF (DUMP_RHS) THEN
  WRITE(IUNIT,FMT='(A)') '%'
  WRITE(IUNIT,FMT='(A,/,A,I10,A,I5)') &
  &  '% A RHS was also written to disk by columns in binary form.', &
  &  '%    Size: N rows x NRHS columns with N=',N,'  NRHS=',NRHS
  WRITE(IUNIT,FMT='(A,I16,A)') &
  &  '%    Total:',int(N,8)*int(NRHS,8),' scalar values.'
  WRITE(IUNIT,'(A)') '%    Single complex storage'
ENDIF
IF (DUMP_BLKPTR) THEN
  WRITE(IUNIT,FMT='(A)') '%'
  WRITE(IUNIT,'(A,I9,A)') '% Matrix has a block format with', &
  &                          NBLK,' blocks'
  WRITE(IUNIT,'(A)') &
  &  '% File <matrix>.blkptr contains NBLK and BLKPTR(1:NBLK+1)'
ELSE IF (ICNTL15 .LT. 0) THEN
  WRITE(IUNIT,FMT='(A)') '%'
  WRITE(IUNIT,'(A,I9,A)') &
  &  '% Matrix has a block format with ICNTL15=',ICNTL15
ENDIF
IF (DUMP_BLKVAR) THEN
    WRITE(IUNIT,'(A)') &
  &    '% File <matrix>.blkvar contains BLKVAR (N integers)'
ELSE IF (ICNTL15 .NE. 0) THEN
    WRITE(IUNIT,'(A)') &
  &    '% (BLKVAR considered to be identity is not written)'
ENDIF
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_DUMP_HEADER
SUBROUTINE @MUMPS_PREFIX@MUMPS_DUMP_MATRIX &
  & (id, IUNIT, I_AM_SLAVE, I_AM_MASTER, &
  &  IS_DISTRIBUTED, IS_ELEMENTAL, PATTERN_ONLY )
USE @MUMPS_PREFIX@MUMPS_STRUC_DEF
IMPLICIT NONE
!
!  Purpose:
!  =======
!     This subroutine dumps a routine in matrix-market format
!     if the matrix is assembled, and in "MUMPS" format (see
!     example in the MUMPS users'guide, if the matrix is
!     centralized and elemental).
!     The routine can be called on all processors. In case of
!     distributed assembled matrix, each processor writes its
!     share as a matrix market file on IUNIT (IUNIT may have
!     different values on different processors).
!
!
!
!  Arguments (input parameters)
!  ============================
!
!     IUNIT: should be set to the Fortran unit where
!            data should be written.
!     I_AM_SLAVE: .TRUE. except on a non working master
!     IS_DISTRIBUTED: .TRUE. if matrix is distributed,
!                     i.e., if IRN_loc/JCN_loc are provided.
!     IS_ELEMENTAL  : .TRUE. if matrix is elemental
!     id            : main MUMPS structure
!
LOGICAL, intent(in) :: I_AM_SLAVE, &
  &                       I_AM_MASTER, &
  &                       IS_DISTRIBUTED, &
  &                       IS_ELEMENTAL, &
  &                       PATTERN_ONLY
INTEGER, intent(in) :: IUNIT
TYPE(@MUMPS_PREFIX@MUMPS_STRUC), intent(in)  :: id
!
!  Local variables:
!  ===============
!
CHARACTER (LEN=10)   :: SYMM
CHARACTER (LEN=8)    :: ARITH
INTEGER(8)           :: I8, NNZ_i
!
!  Executable statements:
!  =====================
IF (I_AM_MASTER .AND. .NOT. IS_DISTRIBUTED .AND. &
  &     .NOT. IS_ELEMENTAL) THEN
!        ==================
!        CENTRALIZED MATRIX
!        ==================
   IF (id%KEEP8(28) .EQ. 0_8) THEN
     CALL MUMPS_GET_NNZ_INTERNAL(id%NNZ, id%NZ, NNZ_i)
   ELSE
     NNZ_i=id%KEEP8(28)
   ENDIF
   IF ((associated(id%A)).AND.(.NOT.PATTERN_ONLY)) THEN
!     Write header line:
         ARITH='@MUMPS_ARITH@'
   ELSE
      ARITH='pattern '
   ENDIF
   IF (id%KEEP(50) .eq. 0) THEN
      SYMM="general"
   ELSE
      SYMM="symmetric"
   END IF
   WRITE(IUNIT,'(A,A,A,A)') '%%MatrixMarket matrix coordinate ', &
  &           trim(ARITH)," ",trim(SYMM)
   WRITE(IUNIT,*) id%N, id%N, NNZ_i
   IF ((associated(id%A)).AND.(.NOT.PATTERN_ONLY)) THEN
      DO I8=1_8,NNZ_i
         IF (id%KEEP(50).NE.0 .AND. id%IRN(I8).LT.id%JCN(I8)) THEN
!              permute upper diag entry
               WRITE(IUNIT,*) id%JCN(I8), id%IRN(I8), &
  &                    @MUMPS_REAL_CONV@(id%A(I8)), aimag(id%A(I8))
         ELSE
               WRITE(IUNIT,*) id%IRN(I8), id%JCN(I8), &
  &                    @MUMPS_REAL_CONV@(id%A(I8)), aimag(id%A(I8))
         ENDIF
      ENDDO
   ELSE
!           pattern only
      DO I8=1_8,id%KEEP8(28)
         IF (id%KEEP(50).NE.0 .AND. id%IRN(I8).LT.id%JCN(I8)) THEN
!                 permute upper diag entry
            WRITE(IUNIT,*) id%JCN(I8), id%IRN(I8)
         ELSE
               WRITE(IUNIT,*) id%IRN(I8), id%JCN(I8)
         ENDIF
      ENDDO
   ENDIF
ELSE IF ( IS_DISTRIBUTED .AND. I_AM_SLAVE ) THEN
!        ==================
!        DISTRIBUTED MATRIX
!        ==================
   IF (id%KEEP8(29) .EQ. 0_8) THEN
     CALL MUMPS_GET_NNZ_INTERNAL(id%NNZ_loc, id%NZ_loc, NNZ_i)
   ELSE
     NNZ_i=id%KEEP8(29)
   ENDIF
   IF ((associated(id%A_loc)).AND.(.NOT.PATTERN_ONLY)) THEN
         ARITH='@MUMPS_ARITH@'
   ELSE
         ARITH='pattern '
   ENDIF
   IF (id%KEEP(50) .eq. 0) THEN
      SYMM="general"
   ELSE
      SYMM="symmetric"
   END IF
   WRITE(IUNIT,'(A,A,A,A)') '%%MatrixMarket matrix coordinate ', &
  &           trim(ARITH)," ",trim(SYMM)
   WRITE(IUNIT,*) id%N, id%N, NNZ_i
   IF ((associated(id%A_loc)).AND.(.NOT.PATTERN_ONLY)) THEN
      DO I8=1_8,NNZ_i
         IF (id%KEEP(50).NE.0 .AND. &
  &             id%IRN_loc(I8).LT.id%JCN_loc(I8)) THEN
               WRITE(IUNIT,*) id%JCN_loc(I8), id%IRN_loc(I8), &
  &                    @MUMPS_REAL_CONV@(id%A_loc(I8)), aimag(id%A_loc(I8))
         ELSE
               WRITE(IUNIT,*) id%IRN_loc(I8), id%JCN_loc(I8), &
  &                    @MUMPS_REAL_CONV@(id%A_loc(I8)), aimag(id%A_loc(I8))
         ENDIF
      ENDDO
   ELSE
      DO I8=1_8,NNZ_i
         IF (id%KEEP(50).NE.0 .AND. &
  &            id%IRN_loc(I8).LT.id%JCN_loc(I8)) THEN
!                 permute upper diag entry
            WRITE(IUNIT,*) id%JCN_loc(I8), id%IRN_loc(I8)
         ELSE
            WRITE(IUNIT,*) id%IRN_loc(I8), id%JCN_loc(I8)
         ENDIF
      ENDDO
   ENDIF
ELSE IF (IS_ELEMENTAL .AND. I_AM_MASTER) THEN
!        ==================
!        ELEMENTAL MATRIX
!        ==================         
   WRITE(IUNIT,*) id%N," :: N"
   WRITE(IUNIT,*) id%NELT," :: NELT"
   WRITE(IUNIT,*) size(id%ELTVAR)," :: NELTVAR"
   WRITE(IUNIT,*) size(id%A_ELT)," :: NELTVL"
   WRITE(IUNIT,*) id%ELTPTR(:)," ::ELTPTR"
   WRITE(IUNIT,*) id%ELTVAR(:)," ::ELTVAR"
   IF(.NOT.PATTERN_ONLY) THEN
      WRITE(IUNIT,*) id%A_ELT(:)
   ENDIF
ENDIF
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_DUMP_MATRIX
SUBROUTINE @MUMPS_PREFIX@MUMPS_DUMP_RHS(IUNIT, id)
!
!  Purpose:
!  =======
!     Dumps a dense, centralized,
!     right-hand side in matrix market format on unit
!     IUNIT. Should be called on the host only.
!
USE @MUMPS_PREFIX@MUMPS_STRUC_DEF
IMPLICIT NONE
!  Arguments
!  =========
TYPE(@MUMPS_PREFIX@MUMPS_STRUC), intent(in)  :: id
INTEGER, intent(in)             :: IUNIT
!
!  Local variables
!  ===============
!
CHARACTER (LEN=8)    :: ARITH
INTEGER              :: I, J
INTEGER(8)           :: LD_RHS8, K8
!
!  Executable statements
!  =====================
!
IF (associated(id%RHS)) THEN
         ARITH='@MUMPS_ARITH@'
  WRITE(IUNIT,'(A,A,A)') '%%MatrixMarket matrix array ', &
  &           trim(ARITH), &
  &           ' general'
  WRITE(IUNIT,*) id%N, id%NRHS
  IF ( id%NRHS .EQ. 1 ) THEN
     LD_RHS8 = int(id%N,8)
  ELSE
     LD_RHS8 = int(id%LRHS,8)
  ENDIF
  DO J = 1, id%NRHS
     DO I = 1, id%N
        K8=int(J-1,8)*LD_RHS8+int(I,8)
           WRITE(IUNIT,*) @MUMPS_REAL_CONV@(id%RHS(K8)), aimag(id%RHS(K8))
  ENDDO
  ENDDO
ENDIF
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_DUMP_RHS
SUBROUTINE @MUMPS_PREFIX@MUMPS_BUILD_I_AM_CAND( NSLAVES, K79, &
  &     NB_NIV2, MYID_NODES, &
  &     CANDIDATES, I_AM_CAND )
IMPLICIT NONE
!
!     Purpose:
!     =======
!     Given  a list of candidate processors per node,
!     returns an array of booleans telling whether the
!     processor is candidate or not for a given node.
!
!     K79 holds splitting strategy (KEEP(79)). If K79>1 then
!     TPYE4,5,6 nodes might have been introduced and 
!     in this case "hidden" slaves should be taken 
!     into account to enable dynamic redistribution 
!     of the hidden slaves while climbing the chain of 
!     split nodes. The master of the first node in the 
!     chain requires a special treatment and is thus here
!     not considered as a slave. 
!     
INTEGER, intent(in) :: NSLAVES, NB_NIV2, MYID_NODES, K79
INTEGER, intent(in) :: CANDIDATES( NSLAVES+1, NB_NIV2 )
LOGICAL, intent(out):: I_AM_CAND( NB_NIV2 )
INTEGER I, INIV2, NCAND
IF (K79.GT.0) THEN
!      Because of potential restarting the number of
!      candidates that will be used to distribute 
!      arrowheads have to include all possible candidates.
 DO INIV2=1, NB_NIV2
   I_AM_CAND(INIV2)=.FALSE.
   NCAND = CANDIDATES(NSLAVES+1,INIV2)
!        check if some hidden slaves are there
!        Note that if hidden candidates exists (type 5 or 6 nodes) then
!        in position CANDIDATES (NCAND+1,INIV2) must be the master 
!        of the first node in the chain (type 4) that we skip here because
!        a special treatment (it has to be "considered as a master" for all 
!        nodes in the list) is needed.
   DO I=1, NSLAVES
      IF (CANDIDATES(I,INIV2).LT.0) EXIT ! end of extra slaves
      IF (I.EQ.NCAND+1) CYCLE
!     skip master of associated TYPE 4 node 
      IF (CANDIDATES(I,INIV2).EQ.MYID_NODES) THEN
         I_AM_CAND(INIV2)=.TRUE.
         EXIT
      ENDIF
   ENDDO
 END DO
ELSE
 DO INIV2=1, NB_NIV2
   I_AM_CAND(INIV2)=.FALSE.
   NCAND = CANDIDATES(NSLAVES+1,INIV2)
   DO I=1, NCAND
      IF (CANDIDATES(I,INIV2).EQ.MYID_NODES) THEN
         I_AM_CAND(INIV2)=.TRUE.
         EXIT
      ENDIF
   ENDDO
 END DO
ENDIF
RETURN
END SUBROUTINE @MUMPS_PREFIX@MUMPS_BUILD_I_AM_CAND
